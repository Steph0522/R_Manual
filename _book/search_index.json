[["index.html", "MANUAL DE R Y RSTUDIO Prefacio 0.1 Objetivo del libro 0.2 Requisitos 0.3 Instalación de Rsudio y R 0.4 Aviso Legal: Protección de Propiedad Intelectual.", " MANUAL DE R Y RSTUDIO Stephanie Hereira-Pacheco Mauricio Hernández Prefacio Este libro contiene la recopilación de temas impartidos y tratados a lo largo de diferentes cursos y lecciones sobre R y sus aplicaciones en Ciencias Biológicas. 0.1 Objetivo del libro Que los estudiantes de nivel pregrado y posgrado puedan aprender temas básicos y aplicados del lenguaje de R y su aplicación en sus estudios y trabajos enfocados en ciencias biológicas. 0.2 Requisitos Rstudio versiones 2024 en adelante. R versiones de 4.0 en adelante. 0.3 Instalación de Rsudio y R En caso de no tener instalado Rstudio y R que son los prerequisitos para llevar a cabo los ejercicios y temas de est elibro, entonces visita estas ligas para descargarlos e instalarlos. 0.3.1 Rstudio En MacOS En Ubuntu En Windows 0.3.2 R Para MacOS Para Ubuntu Para Windows 0.4 Aviso Legal: Protección de Propiedad Intelectual. El material contenido en este manual está protegido por las leyes mexicanas de Propiedad Intelectual. Por lo que su reproducción o distribución no autorizada con fines de lucro está prohibida. "],["introducción-a-r.html", "Capítulo 1 : Introducción a R 1.1 Comenzando con R y RStudio 1.2 Tipos de datos 1.3 Data frames 1.4 Creando subconjuntos o Indexación. 1.5 El directorio de trabajo y rutas 1.6 Funciones de importación 1.7 Algunas funciones Básicas de R", " Capítulo 1 : Introducción a R 1.1 Comenzando con R y RStudio 1.1.1 Breve descripción de R R es un lenguaje de programación como C o Java o Python pero enfocado principalmente a la estadística. No fue creado por ingenieros de software para el desarrollo de software, sino por estadísticos como un ambiente interactivo para el análisis de datos. Otros programas como los que mencioné anteriormente sí están más enfocados en el desarrollo de programas aunque también pueden usarse para hacer cálculos estadísticos. Cuando instalamos R en nuestra computadora en realidad lo que estamos instalando es el entorno computacional y para que podamos hacer uso de ese entorno necesitamos conocer la manera de escribir que el software pueda interpretar y ejecutar las instrucciones que le damos. Eso es lo que aprenderemos a hacer en este curso. Como en otros lenguajes de programación, en R pueden guardar su trabajo como una secuencia de comandos o instrucciones, conocida como un script, que se pueden ejecutar fácilmente en cualquier momento, los podemos guardar y nos servirań siempre. 1.1.2 Un poco de historia…1 R proviene del lenguaje S, creado en los Laboratorios Bell (Estados Unidos). Los mismos que inventaron el transistor, el láser, el sistema operativo Unix y algunas otras cosas más. Ross Ihaka y Robert Gentleman, de la Universidad de Auckland de Nueva Zelanda, decidieron crear una implementación abierta y gratuita de S. Este trabajo, que culminaría en la creación de R inició en 1992 y no fue hasta el 2000 que se obtuvo una versión final estable. Hoy día, el mantenimiento y desarrollo de R es realizado por el R Development Core Team, un equipo de especialistas en ciencias computacionales y estadística provenientes de diferentes instituciones y lugares alrededor del mundo. R posee una Licencia Pública General de GNU, esto, para que pueda ser distribuido de manera gratuita, por lo que es software libre y de código abierto. Esta licencia también te permite usar R para los fines que desees, sin limitaciones, no importando si son personales, académicos o comerciales. 1.1.3 ¿Por qué usar R?2 R es gratuito y de código abierto3. Se ejecuta en todas las plataformas principales: Windows, Mac Os, UNIX/Linux. Los scripts y los objetos de datos se pueden compartir sin problemas entre plataformas. Existe una comunidad grande, creciente y activa de usuarios de R y, como resultado, hay numerosos recursos para aprender y hacer preguntas4 5. Es fácil para otras personas contribuir con complementos (add-ons en inglés) o paquetes que les permiten a los desarrolladores compartir implementaciones de software de nuevas metodologías de ciencia de datos. Esto les da a los usuarios de R acceso temprano a los métodos y herramientas más recientes que se desarrollan para una amplia variedad de disciplinas, incluyendo la ecología, la biología molecular, las ciencias sociales y la geografía, entre otros campos. 1.1.4 RStudio RStudio será nuestra plataforma para los proyectos usados con el lenguaje R. Nos provee un editor visual e interactivo para crear y editar nuestros scripts, además de otras herramientas útiles que iremos viendo con el pasar de los temas. 1.1.5 Interfaz de Rstudio Rstudio posee 4 paneles principales: El panel izquierdo superior aparece nuestro editor de códigos. Donde ponemos los scripts que vamos a correr. A la derecha, el panel superior incluye pestañas como Environment y History, que son el ambiente y el historial, aquí podremos observar los objetos que vayamos declarando y data que subamos, además del historial de scripts. En el panel inferior izquierdo nos aparece nuestra consola de R que es donde se corren los códigos. En el panel inferior derecho se muestran cinco pestañas: File, Plots, Packages, Help y Viewer. Pueden hacer clic en cada pestaña para moverse por las diferentes opciones. Pero a grandes rasgos, en file vemos donde nos encontramos situados y los archivos que hay en nuestro directorio. En plots se visualizan las imágenes que generamos, en packages los paquetes que poseemos instalados y cargados, en Help cuando necesitamos información extra de nuestros paquetes y en Viewer exploramos scripts de rmarkdown. 1.1.6 Scripts Una de las grandes ventajas de R y Rstudio es que se pueden guardar los diversos códigos e instrucciones, los famosos conocidos como scripts, que entonces se pueden editar y guardar con un editor de texto. Para iniciar un nuevo script, hagan clic en Archivo, entonces Nuevo Archivo y luego R Script. Esto inicia un nuevo panel a la izquierda y es aquí donde pueden comenzar a escribir su script. Podemos abrir y ejecutar scripts en R usando la función source(), dandole como argumento la ruta del archivo .R en nuestra computadora, entre comillas o yendo a File, entonces Open File y luego buscando en las carpetas donde tengas el script. Por ejemplo. source(&quot;C:/mi_script.R&quot;) 1.1.6.1 Cómo ejecutar comandos mientras editan scripts Empezamos por abrir un nuevo script y luego nombramos el script. Podemos hacer esto a través del editor guardando el nuevo script actual sin nombre. Al guardar el script por primera vez use un nombre descriptivo, con letras minúsculas, sin espacios, preferiblemente con “_” para separar palabras, evitar guiones “-” para separar las palabras. Llamaremos a este script: mi_script.R. Ahora podemos editar nuestro primer script. Las primeras líneas de código son títulos o comentarios, para hacerlo siempre debemos poner el símbolo “#” para indicar que no es un código y luego cargamos los paquetes y datos que vamos a utilizar. Para esta parte, luego veremos otra sección donde profundizaremos mejor en esto de cargar datos y paquetes. Ahora podemos continuar escribiendo código. Como ejemplo, trabajaremos con “iris” dataset. Cargamos la librería “datasets” y cargamos la data, luego veremos el resumen de los datos y por último graficaremos un boxplot. Para hacer esto, escribimos cada línea de código y luego hacemos click en el botón Run en la parte derecha superior del panel de edición. Para ejecutar una línea pueden usar Control+Enter en Windows y Linux y Command+Return en Mac. Estas son las líneas del código: library(datasets) data(iris) summary(iris) boxplot(iris) Y así luce al correrlo: Tan pronto se corra el código, aparece en la consola y el gráfico aparece en en panel de “Plots” , este panel permite hacer click hacia delante o hacia atrás en diferentes gráficos, hacer zoom en el gráfico o guardar los gráficos como archivos. 1.1.7 Directorio de trabajo El directorio de trabajo es el lugar en nuestra computadora en el que se encuentran los archivos con los que estamos trabajando en R. Este es el lugar donde R busca los archivos para importarlos y al que serán exportados o guardados, a menos que se indique otra cosa. Para saber donde está ubicado tu directorio de trabajo, puedes poner el código: getwd() Y para establecer o cambiar este directorio de trabajo, correr el siguiente código: setwd(&quot;/home/steph/Desktop/&quot;) Por ejemplo en este caso estoy estableciendo mi directorio de trabajo en la carpeta “Escritorio”. También si se quiere conocer el contenido de tu directorio, como archivos o directorios puedes usar los siguientes códigos: list.files() list.dirs() 1.1.8 Sesión Los objetos y funciones de R son almacenados en la memoria de nuestra computadora. Cuando ejecutamos R, ya estamos creando una instancia del entorno computacional de este lenguaje de programación, cada instancia es una sesión. Todos los objetos, tablas, gráficas y funciones creadas en una sesión, permanecen sólo en ella, no son compartidos entre sesiones. Si se quiere guardar toda esta data generada en la sesión antes de cerrar el R hay que indicar que se guarde, sino, aunque se guarden los scripts, los objetos (que algunos pueden ser muy pesados y ocupar memoria) no se guardarán. Lo cual es una opción si no se tiene mucho espacio en el disco. Es posible tener más de una sesión de R activa en la misma computadora. Esto se guarda en un archivo con extensión **.Rdata* en tu directorio de trabajo. Con la función ls() conoceremos una lista con los nombres de todo lo guardado en la sesión. En las siguientes imágenes ilustro como crear un nuevo proyecto: 1.1.9 Proyecto Un proyecto de R (extensión .Rproj) identifica todos los archivos y contenido asociado con él. Ayuda a organizar tu trabajo y así cada curso, artículo o trabajo diferente puede tener un proyecto diferente. Al crear un proyecto todos los ficheros quedan vinculados directamente a él. 1.1.10 Instalación de paquetes de R Dentro de las ventajas de R está que muchos desarrolladores y programadores elaboran constantemente complementos, aplicaciones o en palabras propias paquetes que nos permiten usar en acceso libre y que tienen muchas funcionalidades. Actualmente hay muchos disponibles en CRAN (Comprehensive R Archive Network) que es una red de servidores alrededor del mundo que almacena versiones actualizadas del código de R y su documentación. También hay muchos paquetes desarrollados publicados en GitHub y en Bioconductor. Por ejemplo para instalar el paquete tidyverse, que es de gran utilidad y que veremos en sesiones posteriores, usamos el código: install.packages(&quot;tidyverse&quot;) En RStudio pueden navegar a la pestaña Pakages y seleccionar Install. Luego, escribir el paquete que queremos siempre y cuando esté en CRAN. Para cargar una librería como lo vimos anteriormente se usa la función, library(): library(tidyverse) Una vez que se instalan los paquetes, no deben instalarlo de nuevo, sin embargo, cada vez que cerramos sesión, reiniciamos sesión o abrimos un nuevo proyecto o sesión tenemos que volver a cargarlos. Debemos tener en cuenta que la instalación de tidyverse instala varios paquetes. Esto ocurre comúnmente cuando un paquete tiene dependencias, es decir usa funciones de otros paquetes. Cuando cargan un paquete usando library, también cargan sus dependencias. Hay paquetes que no se encuentra en CRAN o que si queremos su versión en desarrollo, se necesitan de otros paquetes para ser instalados, por ejemplo, si queremos instalar la versión en desarrollo del paquete “rmarkdown”, que se encuentra en github, se utiliza el paquete devtools: devtools::install_github(&#39;rstudio/rmarkdown&#39;) Los dos puntos “::” se utilizan para denotar que llamamos la función de un paquete pero sin llamarla permanentemente en nuestra sesión. 1.1.11 Tipos de objetos en R La información que manipulamos en R se estructura en forma de objetos y los podemos ver almacenados en el panel del ambiente de trabajo o Enviroment. Los objetos pueden ser: Números escalares o letras Vectores y matrices Dataframes, tablas y listas Más adelante detallaremos este tipo de objetos o datos en R. Aquí unos ejemplos: a &lt;- 1 #escalar letra &lt;- &quot;a&quot; #caracter o letra b &lt;- c(1,2,3) #vector c&lt;- matrix(1:10) #matriz d&lt;- data.frame(Especie=c(&quot;A&quot;, &quot;B&quot;), Longitud=c(c(1,2))) #dataframe o tabla e&lt;- list(c(1:20), c(1:10)) #lista Una ventaja de los lenguajes de programación es poder definir variables y escribir expresiones como estas, como se hace en las matemáticas y así almacenar los valores para su uso posterior. Usamos &lt;- para asignar valores a las variables. También podemos asignar valores usando = en lugar de &lt;-, pero recomendamos no usar =. Esto, debido a que en R el signo = implica igualdad en términos lógicos y no asignación y esto puede evitarnos confusiones en el futuro. Para ver el valor almacenado en una variable, simplemente le pedimos a R que evalúe a y R nos muestra el valor almacenado: a ## [1] 1 Una forma explícita de pedirle a R que nos muestre el valor almacenado en a es usar print así: print(a) ## [1] 1 Otra forma de examinar los objetos es buscarlos en el Enviorment o ambiente de trabajo y visualizarlos desde allí. Deberíamos ver a, b y las que ya hemos declarado en el ambiente. Si intentamos imprimir o visualizar el valor de un objeto que no está definido en el ambiente se recibirá un mensaje de error. Por ejemplo, si escriben f, verán lo siguiente: Error: object 'f' not found. 1.1.11.0.1 Algunos tips para asignar variables u objetos en R… Los nombres de variables tienen que comenzar con una letra, no pueden contener espacios y no deben ser variables predefinidas en R (como funciones o argumentos de funciones). Por ejemplo, no nombren una de sus variables install.packages escribiendo algo como: install.packages &lt;- 2. Esto reescribe la función o causa confusiones para R. Que tus nombres sean descriptivos y/o significativos para lo que se está almacenado, usar solo minúsculas y usar guiones bajos ( _ ) como sustituto de espacios, evitar caracteres especiales (- ; . @ ?) . 1.1.11.1 Guardar los espacios de trabajo y exportar objetos de R Los objetos evaluados permanecen en el espacio de trabajo hasta que finalicen sus sesiones sin guardar. Pero los espacios de trabajo también se pueden guardar para su uso posterior. De hecho, al salir de R, el programa les pregunta si desean guardar su espacio de trabajo. Si lo guardan, la próxima vez que inicien R, el programa restaurará el espacio de trabajo con todos los objetos en él. Sin embargo, no se recomienda guardar el espacio de trabajo porque sino se trabaja con diferentes proyectos, será más difícil darle seguimiento de lo que guardan y ocupara mucho espacio en la memoria de su disco. En cambio, se recomienda en gran medida realizar un proyecto por trabajo o tarea y así tener un espacio de trabajo para cada uno. Decidiendo o no si guardar las sesiones y no entrar en confusiones entre las diferentes sesiones. Ahora bien R ya posee funciones de exporte, tales como: library(readr) write_tsv(d, &quot;data.tsv&quot;) write.table(d, &quot;data.txt&quot;, sep = &quot;\\t&quot;) write_csv(d, &quot;data.csv&quot;) Estas funciones guardan tus tablas u objetos con formatos de texto. También hay una forma de guardar objetos de R sin declararlos como texto sino que se queden con la identidad de R: saveRDS(d, &quot;data.RDS&quot;) Y para abrir o cargar este tipo de objetos con extensión .RDS usamos la siguiente función: readRDS(&quot;data.RDS&quot;) 1.1.12 Funciones en R6 Una vez que definidos los objetos o las variables, si queremos continuar con el análisis de datos generalmente se usan una serie de funciones específicas que se aplican a las variables o datos. R incluye muchas funciones por default o preestablecidas y otras pueden extraerse al cargar los diversos paquetes. A lo largo de este curso ya hemos usado varias funciones tales como las funciones para exportar datos como write_csv() o para cargar paquetes tales como library(), entre otras. Hay otras funciones más sencillas como por ejemplo la función log o sqrt con las que podemos obtener el logaritmo o la raíz cuadrada. (Nótese que las funciones en su gran mayoría están definidas en inglés). Muchas otras funciones vienen establecidas en otros paquetes como fue el caso que vimos de read_csv() del paquete readr. La sintaxis o el lenguaje de R nos indica que necesitas usar paréntesis para evaluar funciones como hemos visto en los ejemplos anteriores que hemos usado funciones. Algunas funciones como ls() no requieren argumentos sino que nos da la información que ocupamos sin evaluar nada dentro de los paréntesis. Sin embargo, en otras funciones sí requieren uno o más argumentos. A continuación se muestra un ejemplo de cómo asignamos un objeto al argumento de la función log. Recuerden que anteriormente definimos a como 1: log(a) ## [1] 0 Podemos explorar funciones en el panel inferior derecho en la pestaña de Packages o Paquetes podemos explorar los paquetes y al hacer click en alguno nos despliega las funciones que posee y su documento de ayuda también. Se puede saber cuáles son los argumentos de la función o lo que la función espera o las opciones que tiene, con el comando help o también anteponiendo un signo ? antes de la función. También mientras escribimos la función si usamos la tecla tab nos indica también que argumentos espera esta función. Pueden averiguar lo que la función espera y lo que hace revisando unos manuales muy útiles incluidos en R. Pueden obtener ayuda utilizando la función help así: help(&quot;log&quot;) ?log La página de ayuda les mostrará qué argumentos espera la función. Por ejemplo, log necesita x y base para correr. Sin embargo, algunos argumentos son obligatorios y otros son opcionales. Pueden determinar cuáles son opcionales notando en el documento de ayuda cuáles valores predeterminados se asignan con =. Definir estos es opcional. Por ejemplo, la base de la función log por defecto es base = exp(1) que hace log el logaritmo natural por defecto. Para echar un vistazo rápido a los argumentos sin abrir el sistema de ayuda, pueden escribir: args(log) ## function (x, base = exp(1)) ## NULL Pueden cambiar los valores predeterminados simplemente asignando otro objeto: log(x = 8, base = 2) ## [1] 3 El código anterior funciona, pero también podemos ahorrarnos un poco de escritura: si no usan un nombre de argumento, R supone que están ingresando argumentos en el orden en que se muestran en la página de ayuda o por args. Entonces, al no usar los nombres, R supone que los argumentos son x seguido por base: log(8,2) ## [1] 3 Si se usan los nombres de los argumentos, podemos incluirlos en el orden en que queramos: log(base = 2, x = 8) ## [1] 3 Para especificar argumentos, debemos usar = y no &lt;-. Aquí si aplica la igualdad, en el caso de las funciones. Hay algunas excepciones a la regla de que las funciones necesitan los paréntesis para ser evaluadas. Entre estas, las más utilizados son los operadores aritméticos y relacionales. Por ejemplo: a + a ## [1] 2 a - 2 ## [1] -1 1 * pi ## [1] 3.141593 2 / 3 ## [1] 0.6666667 4 ^ a ## [1] 4 También es posible declarar una función que a lo mejor no esté definida en R. Por ejemplo, la función mean() en Rbase nos da el promedio de un conjunto de datos, pero si quisieramos definirla en caso de no conocerla o hacerlo a nuestra manera, sería algo así: average&lt;- function(x){sum(x)/length(x)} x&lt;- 1:100 average(x) ## [1] 50.5 mean(x) ## [1] 50.5 Al compararlas nos arrojan el mismo valor. Lo importante de este punto es que hemos declarado una nueva función, declarando primero la variable (o variables, dependiendo el caso) y luego las operaciones y asignandolos a un objeto de R: nombre &lt;- function(argumentos) { operaciones} Para trabajar con R resulta importante conocer los principales tipos de objetos y sus propiedades básicas. 1.2 Tipos de datos Como vimos en el ejemplo anterior, los objetos en R pueden ser de varios tipos. Por ejemplo, necesitamos distinguir números de los caracteres. La función class nos ayuda a determinar qué tipo de objeto tenemos: a &lt;- 5 class(a) ## [1] &quot;numeric&quot; Tipo Nombre en inglés/en R Ejemplo Numérico numeric 5.1 Entero integer 4 Real double/float 3.4 Cadena de texto, letra character “a” Factor factor Bajo Lógico logic TRUE, FALSE Perdido/Omitido NA NA Vacío null NULL Existen otro tipos de datos más complejos que no están en el alcance del presente curso, por ejemplo: números complejos, fechas, entre otros. 1.2.0.1 Para tener en cuenta… El tipo character representa texto y es fácil reconocerlo porque un dato siempre esta rodeado de comillas, simples o dobles. Este es el tipo de datos más flexible de R, pues una cadena de texto puede contener letras, números, espacios, signos de puntuación y símbolos especiales. Un factor es un tipo de datos específico a R. Puede ser descrito como un dato numérico representado por una etiqueta. Por último, cada una de las etiquetas o valores que puedes asumir un factor se conoce como nivel o level. los niveles tienen un orden diferente al orden de aparición en el factor. En R, por defecto, los niveles se ordenan alfabéticamente. Advertencia: Los factores pueden causar confusión ya que a veces se comportan como caracteres y otras veces no. Como resultado, estos son una fuente común de errores. A veces las funciones necesitan a fuerza que se ocupe un vector y a veces lo contrario. La diferencia entre las dos es que un dato NULL aparece sólo cuando R intenta recuperar un dato y no encuentra nada, mientras que NA es usado para representar explícitamente datos perdidos, omitidos o que por alguna razón son faltantes. NA además puede aparecer como resultado de una operación realizada, pero no tuvo éxito en su ejecución. 1.2.0.2 Coerción de datos… En R, los datos pueden ser coercionados, es decir, forzados, para transformarlos de un tipo a otro. Función de coerción Tipo as.integer() Entero as.numeric() Numérico as.character() Caracter as.factor() Factor as.logical() Lógico Veamos algunos ejemplos: a&lt;- 5 as.character(a) ## [1] &quot;5&quot; as.factor(&quot;medio&quot;) ## [1] medio ## Levels: medio 1.2.1 Tipos de estructura de los datos Los datos se estructuran de diferentes formas dependiendo de su propósito, en todo caso, la función class() también nos puede dar información sobre los tipos de estructuras de datos. 1.2.1.1 Vectores Los vectores son colecciones de uno o más datos del mismo tipo. Por ejemplo, si tenemos un vector con datos numéricos tenemos un vector de tipo numérico. No es posible mezclar datos de tipos diferentes dentro de ellos. Por ejemplo, un vector de colores puede ser: colores&lt;- c(&quot;red&quot;, &quot;black&quot;, &quot;blue&quot;) is.vector(colores) ## [1] TRUE class(colores) ## [1] &quot;character&quot; Al usar las funcion is.vector() corroboramos que efectivamente es un vector al darnos TRUE pero al pedirle que nos indique el tipo con la función class nos dice que es un “character” es decir que es un vector de una cadena de texto. Existen algunas operaciones al aplicarlas a un vector, se aplican a cada uno de sus elementos. A este proceso le llamamos vectorización. Las operaciones aritméticas y relacionales pueden vectorizarse. Si las aplicamos a un vector, la operación se realizará para cada uno de los elementos que contiene. un_vector &lt;- c(1:10) un_vector*10 ## [1] 10 20 30 40 50 60 70 80 90 100 un_vector+1 ## [1] 2 3 4 5 6 7 8 9 10 11 un_vector + un_vector ## [1] 2 4 6 8 10 12 14 16 18 20 1.2.1.2 Matrices y arreglos Las matrices y arreglos no son más que vectores multidimensionales, es decir un conjunto de vectores. Al igual que un vector deben contener un sólo tipo de datos. En sentido estricto, una arreglo es una matrix pero con n dimensiones, mientras que las matrices tienen solo dos dimensiones. Las matrices y los arreglos suelen ser usados de manera regular en matemáticas y estadística, por ser sencillas y contener solo un tipo de datos (usualmente de tipo numérico). En general, es preferible usar listas en lugar de arrays, una estructura de datos que además tienen ciertas ventajas que se revisará más adelante. En R, podemos usar el símbolo : para indicar una secuencia de números que tiene un principio y fin, por ejemplo: vect&lt;- 1:20 Este es un vector con números que va desde el 1 al 20. Pero para hacerlo matriz hacemos: matr&lt;- matrix(1:20) O para dividirlo en varias renglones y columnas: matri&lt;-matrix(1:20, nrow = 5, ncol = 4) dim(matri) ## [1] 5 4 matri ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Con la función dim() podemos saber cuales son las dimensiones (es decir, largo y ancho) de nuestra matriz. Las operaciones aritméticas también son vectorizadas al aplicarlas a una matriz. La operación es aplicada a cada uno de los elementos de la matriz al igual que los vectores. matri*2 ## [,1] [,2] [,3] [,4] ## [1,] 2 12 22 32 ## [2,] 4 14 24 34 ## [3,] 6 16 26 36 ## [4,] 8 18 28 38 ## [5,] 10 20 30 40 Algo más que podemos hacer es tranponer una matriz para rotarla 90°. t(matri) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 ## [4,] 16 17 18 19 20 1.2.1.3 Listas Las listas, al igual que los vectores, son estructuras de datos unidimensionales, sólo tienen largo, pero a diferencia de los vectores cada uno de sus elementos puede ser de diferente tipo o incluso de diferente clase, por lo que son estructuras heterogéneas. Podemos tener listas que contengan escalares, vectores, matrices, data frames u otras listas. Para crear una lista usamos la función list(), que nos pedirá los elementos que deseamos incluir en nuestra lista. Para esta estructura, no importan las dimensiones o largo de los elementos que queramos incluir en ella. Al igual que con un data frame, tenemos la opción de poner nombre a cada elemento de una lista. un_vector &lt;- 1:20 una_matriz &lt;- matrix(1:4, nrow = 5) ## Warning in matrix(1:4, nrow = 5): data length [4] is not a sub-multiple or multiple of the number of ## rows [5] una_df &lt;- data.frame(&quot;numeros&quot; = 1:3, &quot;letras&quot; = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) una_lista &lt;- list(&quot;vector&quot; = un_vector, &quot;matriz&quot; = una_matriz, &quot;df&quot; = una_df) una_lista ## $vector ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## ## $matriz ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 1 ## ## $df ## numeros letras ## 1 1 a ## 2 2 b ## 3 3 c No es posible vectorizar operaciones aritméticas usando listas. Al intentarlo nos es devuelto un error. Finalmente, en caso de que sea necesario utilizar funciones que requieran a fuerza una matrix o un data frame también aplica la coerción entre estas dos estructuras de datos: coerción_df&lt;- as.data.frame(una_matriz) coerción_mat&lt;- as.matrix(una_df) class(coerción_df); class(coerción_mat) ## [1] &quot;data.frame&quot; ## [1] &quot;matrix&quot; &quot;array&quot; Esta coerción es muy útil por ejemplo al utilizar la función t() que transponer una data frame: df_transpuesta&lt;- t(una_df) class(df_transpuesta) ## [1] &quot;matrix&quot; &quot;array&quot; Como vemos la función t() cambia la estructura de los datos, para evitar esto, coercionamos esta salida. df_transpuesta&lt;- as.data.frame(t(una_df)) class(df_transpuesta) ## [1] &quot;data.frame&quot; 1.3 Data frames La forma más común de almacenar un set de datos en R es usando un data frame. Los data frames son estructuras de datos de dos dimensiones (rectangulares) que pueden contener datos de diferentes tipos, por lo tanto, son heterogéneas. Podemos entender a los data frames como una versión más flexible de una matriz. Mientras que en una matriz todas las celdas deben contener datos del mismo tipo, los renglones de un data frame admiten datos de distintos tipos, pero sus columnas conservan la restricción de contener datos de un sólo tipo. Vamos a trabajar con una data de ejemplo y exploraremos esta data frame, es una data en la que evaluan el efecto de la dosis de vitamina C sobre el crecimiento de los dientes de unos tipos de cerdos. La función str es útil para obtener más información sobre la estructura de un objeto: data(ToothGrowth) str(ToothGrowth) ## &#39;data.frame&#39;: 60 obs. of 3 variables: ## $ len : num 4.2 11.5 7.3 5.8 6.4 10 11.2 11.2 5.2 7 ... ## $ supp: Factor w/ 2 levels &quot;OJ&quot;,&quot;VC&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ dose: num 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ... Esto nos dice mucho más sobre el objeto. Vemos que la tabla tiene 60 filas y 3 variables. Podemos mostrar las primeras seis líneas usando la función head: head(ToothGrowth) ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10.0 VC 0.5 Para crear un data frame usamos la función data.frame(). Esta función nos pedirá un número de vectores igual al número de columnas que deseemos. Todos los vectores que proporcionemos deben tener el mismo largo. Es decir, un data frame está compuesto por vectores. Veamos un ejemplo: df &lt;- data.frame( &quot;entero&quot; = 1:3, &quot;factor&quot; = c(&quot;alto&quot;, &quot;medio&quot;, &quot;bajo&quot;), &quot;letras&quot; = as.character(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ) df ## entero factor letras ## 1 1 alto a ## 2 2 medio b ## 3 3 bajo c dim(df) ## [1] 3 3 La función dim nos permite conocer también las dimensiones de nuestra data frame. En este caso tenemos 3 filas y 3 columnas. Las funciones names y colnames nos permiten conocer los nombres de los headers o de las columnas. names(df) ## [1] &quot;entero&quot; &quot;factor&quot; &quot;letras&quot; colnames(df) ## [1] &quot;entero&quot; &quot;factor&quot; &quot;letras&quot; 1.3.1 El operador $ y otras formas de acceso Para tener acceso a las diversas variables o columnas de un data.frame utilizamos el operador de acceso $, por ejemplo, si quisieramos tener acceso a la variable ‘factor’ de la data.frame df de la siguiente manera: df$factor ## [1] &quot;alto&quot; &quot;medio&quot; &quot;bajo&quot; class(df$factor) ## [1] &quot;character&quot; is.vector(df$factor) ## [1] TRUE Cuando usamos el operador $ el tipo de objeto que obtenemos es un vector, en el ejemplo como la columna ‘factor’ es una cadena de caracteres entonces al usar las funciones class() y is.vector() nos confirma lo antes mencionado. Tip: R viene con una muy buena funcionalidad de autocompletar que nos ahorra la molestia de escribir todos los nombres. Escriban df$f y luego presionen la tecla tab en su teclado. Esta funcionalidad y muchas otras características útiles de autocompletar están disponibles en RStudio, esto aplica también para las funciones. En el caso de las listas también podemos acceder con el operador $, aunque también podemos usar corchetes dobles ([[) así. Por ejemplo declaramos una lista: notas_estudiantes &lt;- list(nombres = c(&quot;Ana&quot;, &quot;Clara&quot;, &quot;Sofy&quot;), id_estudiante = c(&quot;i1&quot;, &quot;i2&quot;, &quot;i3&quot;), notas = c(10, 9,7)) Y queremos extraer los nombres de los estudiantes, entonces hacemos_ notas_estudiantes$nombres ## [1] &quot;Ana&quot; &quot;Clara&quot; &quot;Sofy&quot; notas_estudiantes[[&quot;nombres&quot;]] ## [1] &quot;Ana&quot; &quot;Clara&quot; &quot;Sofy&quot; Y obtenemos el mismo resultados. Para el caso de las matrices se puede acceder usando corchetes ([). Si desean la primera fila y la pimera columna, entonces: mat&lt;- matrix(1:10, ncol = 2, nrow = 5) mat[1,1] ## [1] 1 mat ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 ## [3,] 3 8 ## [4,] 4 9 ## [5,] 5 10 Para acceder solo a la primera fila y solo a la primera columa usamos las comas, así: s mat[1, ] #acceder primera fila ## [1] 1 6 mat[, 1] #acceder a la primera columna ## [1] 1 2 3 4 5 is.vector(mat[, 1]) ## [1] TRUE Notese que esto devuelve un vector, no una matriz. Del mismo modo, si desean la segunda columna completa, dejen el lugar de la fila vacío: mat[, 2] ## [1] 6 7 8 9 10 Esto también es un vector, no una matriz. Lo corroboramos con la función is.vector() Se pueden crear subconjuntos basados tanto en las filas como en las columnas: mat[2:4 , 1:2] #en orden de posición es filas primero y luego columnas ## [,1] [,2] ## [1,] 2 7 ## [2,] 3 8 ## [3,] 4 9 Podemos convertir las matrices en data frames usando la función as.data.frame: as.data.frame(mat) ## V1 V2 ## 1 1 6 ## 2 2 7 ## 3 3 8 ## 4 4 9 ## 5 5 10 1.4 Creando subconjuntos o Indexación. En R, podemos obtener subconjuntos de nuestras estructuras de datos. Es decir, podemos extraer partes de una estructura de datos (nuestro conjunto). También podemos usar corchetes individuales ([) para acceder a las filas y las columnas de un data frame y es exactamente igual que lo que se aplicó con las matrices. A esto es lo que llamamos Subconjuntos de los data.frame. Como las listas de datos que usamos para notas_estudiantes tienen las mismas dimensiones entonces podemos coercionarlo a ser una data.frame: evaluaciones&lt;- as.data.frame(notas_estudiantes) Y para obtener más de una entrada se puede utilizar un vector de entradas múltiples como índice: evaluaciones[c(1,2)] ## nombres id_estudiante ## 1 Ana i1 ## 2 Clara i2 ## 3 Sofy i3 Obtenemos las dos primeras columnas. Las secuencias definidas anteriormente son particularmente útiles si necesitamos acceso, digamos, a los dos primeros elementos: evaluaciones[1:2] ## nombres id_estudiante ## 1 Ana i1 ## 2 Clara i2 ## 3 Sofy i3 Ahora bien, si queremos NO elegir por ejemplo la primera columna o dejarla por fuera, entonces usamos el signo ‘-’: evaluaciones[,-1] ## id_estudiante notas ## 1 i1 10 ## 2 i2 9 ## 3 i3 7 Si los elementos tienen nombres de columna o headers también podemos acceder a las entradas utilizando estos nombres: evaluaciones[c(&quot;nombres&quot;,&quot;notas&quot;)] ## nombres notas ## 1 Ana 10 ## 2 Clara 9 ## 3 Sofy 7 Ahora bien, podemos seleccionar datos que tengan características específicas, por ejemplo, todos los valores mayores a cierto número o aquellos que coinciden exactamente con un valor de nuestro interés. Para realizar esta operación haremos uso de índices y operadores lógicos. Operador Comparación &lt; Menor que &lt;= Menor o igual que &gt; Mayor que &gt;= Mayor o igual que == Exactamente igual que ! = No es igual que ! No es = Igual que &amp;, | y, ó Por ejemplo en el caso de la tabla de evaluaciones, si queremos escoger los valores que sean mayor de 8 en las notas obtenidas: evaluaciones$notas &gt; 8 ## [1] TRUE TRUE FALSE Observamos cuales cumplen con la condición si muestran TRUE. Ahora para usar este filtro y hacer un subconjunto con el data.frame, hacemos: mas_de_8&lt;-evaluaciones[evaluaciones$notas &gt; 8,] mas_de_8 ## nombres id_estudiante notas ## 1 Ana i1 10 ## 2 Clara i2 9 Si queremos usar más de una condición pero indicando negación: evaluaciones[!(evaluaciones$notas &gt; 8 &amp; evaluaciones$nombres == &quot;Clara&quot;), ] ## nombres id_estudiante notas ## 1 Ana i1 10 ## 3 Sofy i3 7 Para escoger un valor que sea exactamente igual a una condición usamos ‘==’: evaluaciones[evaluaciones$nombres == &quot;Sofy&quot;,] ## nombres id_estudiante notas ## 3 Sofy i3 7 1.4.1 Importando datos Para el ejemplo que vimos en el capítulo pasado usamos un dataset que está en el ambiente de R por default, si queremo saber cuales son los datasets que tenemos en nuestro ambiente, podemos usar el comando data() y nos desplegará la lista: data() Si queremos utilizar los datos de nuestro trabajo o usar datos de una base de datos o que de una ‘dataset’ que se encuentre en internet, debemos Importar estos datos a nuestra sesión de R. Usualmente tenemos nuestros datos guardados en hojas de cálculo en diferentes formatos con diferentes extensiones, estos son los más populares: separados con coma o punto y coma (,,;): csv, separados con tabulaciones o espacios (tab, \\t) : .txt o .tsv, Hojas de cálculo de excel: .xls, son las más usadas. A continuación muestro una imagen de como se ven un .csv y .txt: 1.5 El directorio de trabajo y rutas Antes de importar nuestros propios archivos, tablas o datos debemos estar seguros en qué directorio nos encontramos, para estar seguros que vamos a importar el archivo deseado a R. Existen tres opciones para esto: Utilizar getwd() y setwd(), como lo vimos anteriormente, para establecer y saber en qué directorio nos encontramos y si es el caso, cambiarlo. Poner la ruta completa de nuestro archivo, sin importar donde esté. Utilizar “Import Dataset” de nuestro panel de ambiente y ubicar manualmente la ubicación del archivo. El reto de la primera opción es permitir que las funciones de importación de R sepan dónde buscar el archivo que contiene los datos. La forma más sencilla de hacer esto es tener una copia del archivo en la carpeta donde las funciones de importación buscan por defecto, es decir guardar este archivo en nuestro directorio de trabajo. 1.5.1 Descargando un archivo de la web Para descargar algún archivo en la web a utilizar, podemos correr el siguiente código: download.file( url = &quot;https://raw.githubusercontent.com/sagar3122/Machine-Learning/refs/heads/master/iris.data.txt&quot;, destfile = &quot;iris.data&quot;) Si observamos nuestros archivos en nuestro directorio de trabajo con el código list.files() veremos que se encuentra esta data que hemos descargado. El código anterior no lee los datos sólo, en este caso, descarga la data. Otra forma de descargarlo y a la vez abrirlo es de la siguiente manera, con el paquete readr: iris_dat&lt;-readr::read_csv(&quot;https://raw.githubusercontent.com/sagar3122/Machine-Learning/refs/heads/master/iris.data.txt&quot;) 1.6 Funciones de importación Una vez descargado o que se encuentre en nuestro directorio de trabajo, podemos importar los datos con solo una línea de código. Aquí usamos la función read.csv o read.delim de R base (que viene default cuando descargamos R). iris_data&lt;- read.csv(&quot;iris.data&quot;, header = F) iris_data&lt;- read.delim(&quot;iris.data&quot;,header = F, sep = &quot;,&quot;) Los datos se importan y almacenan en el obejto iris_dat. Los argumentos header = F y sep=“,” son parámetros extras que podemos agregar a la función para indicarle algunas cosas. Por ejemplo header=F, le estamos diciendo que la prima fila no contiene los títulos o headers de la tabla, en caso de que si fuera así, le daríamos TRUE. Podemos usar la tecla ‘tab’ para explorar las demás opciones que podemos utilizar en estas funciones. También el paquete readr tiene otras funciones de importación muy parecidas: library(readr) iris_data&lt;-read_csv(&quot;iris.data&quot;, col_names = c(&quot;Longitud.sepalo&quot;, &quot;Ancho.Sepalo&quot; , &quot;Longitud.Petalo&quot; ,&quot;Ancho.Petalo&quot; , &quot;Especies&quot; )) En esta función usamos el argumento col_names para establecer los Headers o nombre de las columnas de esta tabla. La segunda opción que vimos es utilizar la ruta completa del archivo, por ejemplo: data&lt;- read_csv(&quot;Data/penguins_size.csv&quot;) ## Rows: 344 Columns: 7 ## ── Column specification ─────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (3): species, island, sex ## dbl (4): culmen_length_mm, culmen_depth_mm, flipper_length_mm, body_mass_g ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. En este ejemplo, la data que importamos está ubicada en la carpeta de ‘Data’ de este proyecto. Y vemos que esta función de readr también nos da información del archivo como el tipo de variable y el nombre de las mismas. La última opción, un poco más fácil para algunos y más interactiva es usar Import Dataset del planel del ambiente. En esta opción podemos importar tablas con cualquiera de las funciones que despliega dependiendo del tipo de archivo, yo recomiendo si es .csv o .txt usar readr que es el mismo que usa tidyverse, como lo vimos anteriormente. Paquete que veremos más detalladamente junto con readxl en la siguiente sección. 1.6.1 Los paquetes readr y readxl7 1.6.1.1 readr El paquete readr un paquete de tiyverse, tiene las siguientes funciones para importar arvhivos con diferentes extensiones: Función Tipo de archivo Extensión read_table valores separados por espacios en blanco txt read_csv valores separados por comas csv read_csv2 valores separados por punto y coma csv read_tsv valores separados delimitados por tab tsv o txt read_delim formato de archivo de texto general, debe definir delimitador txt, csv o tsv 1.6.1.2 readxl Este paquete ofrece funciones para leer archivos provienetes de Microsoft Excel: Función Formato Sufijo típico read_excel detectar automáticamente el formato xls, xlsx read_xls formato original xls read_xlsx nuevo formato xlsx 1.6.2 Algunos tips para hojas de cálculo de excel… Evitar cosas como tener muchos diferentes formatos (colores, subrayados, etc). Evitar en lo posible celdas vacías y poner un dato en cada celda Evitar celdas con cálculo o aplicación de fórmulas. Tenga en cuenta que nuestros datos que tenemos en hojas de cálculo en excel también podemos guardarlos en otros formatos un poco más fáciles para ser importados como los que ya vimos (.csv y .txt). Esto utilizando la opción Guardar como y escogiendo el tipo de formato deseado. En la imagen podemos ver un ejemplo de esto: 1.7 Algunas funciones Básicas de R 1.7.1 sort y order Digamos que queremos clasificar las notas de la mayor a la menor, podemos usar alguna de estas dos funciones: sort(evaluaciones$notas) ## [1] 7 9 10 order(evaluaciones$notas) ## [1] 3 2 1 1.7.2 max y which.max Si solo estamos interesados en la entrada con el mayor valor, podemos usar max: max(evaluaciones$notas) ## [1] 10 y which.max nos dice que valor es el mayor, posicionalmente: which.max(evaluaciones$notas) ## [1] 1 Para el mínimo, podemos usar min y which.min del mismo modo. 1.7.3 which La función which nos dice qué entradas de un vector lógico son TRUE. Entonces podemos escribir: ind &lt;- which(evaluaciones$nombres == &quot;Ana&quot;) ind ## [1] 1 evaluaciones[ind,] ## nombres id_estudiante notas ## 1 Ana i1 10 De esta forma también podemos usarlo para filtrar y hacer subconjuntos. 1.7.4 match La función match nos dice qué índices de un segundo vector coinciden con cada una de las entradas de un primer vector: v1&lt;- c(&quot;Uvas&quot;, &quot;Peras&quot;, &quot;Mandarinas&quot;, &quot;Plátanos&quot;, &quot;Manzanas&quot;) v2&lt;- c(&quot;Uvas&quot;,&quot;Cerezas&quot;, &quot;Mandarinas&quot;, &quot;Naranjas&quot;, &quot;Manzanas&quot;) match(v1, v2) ## [1] 1 NA 3 NA 5 match(c(&quot;Peras&quot;, &quot;Plátanos&quot;), v1) ## [1] 2 4 ind&lt;-match(c(&quot;Peras&quot;, &quot;Plátanos&quot;), v1) v1[ind] ## [1] &quot;Peras&quot; &quot;Plátanos&quot; Este filtro puede aplicarse de igual manera a un data.frame: ind2&lt;- match(v1, v2) frutas&lt;- data.frame(persona1=v1,persona2=v2) frutas[ind,] ## persona1 persona2 ## 2 Peras Cerezas ## 4 Plátanos Naranjas na.omit(frutas[ind2,]) #na.omit() nos permite quitar las celdas que contienen NA&#39;s ## persona1 persona2 ## 1 Uvas Uvas ## 3 Mandarinas Mandarinas ## 5 Manzanas Manzanas 1.7.5 %in% Si en lugar de un índice queremos un lógico que nos diga si cada elemento de un primer vector está en un segundo vector, podemos usar la función %in%. Siguiendo el ejemplo pasado: c(&quot;Peras&quot;, &quot;Plátanos&quot;) %in% frutas$persona1 ## [1] TRUE TRUE Nos dice que los dos elementos qu buscamos están presente en el data.frame() Avanzado: match y %in% pueden dar el mismo output usando which: match(c(&quot;Peras&quot;, &quot;Plátanos&quot;), frutas$persona1) ## [1] 2 4 which(frutas$persona1 %in% c(&quot;Peras&quot;, &quot;Plátanos&quot;)) ## [1] 2 4 1.7.6 La familia de funciones apply Esta familia de funciones es usada para aplicar una función a cada elemento de una estructura de datos. En particular, es usada para aplicar funciones en matrices, data frames, arreglos y listas. Para entender más fácilmente el uso de la familia apply, recordemos la vectorización de operaciones. Hay operaciones que, si las aplicamos a un vector, son aplicadas a todos sus elementos. La familia apply esta formada por las siguientes funciones: apply() lapply() mapply() sapply() eapply() rapply() tapply() vapply() Es una familia numerosa y esta variedad de funciones se debe a que varias de ellas tienen aplicaciones sumamente específicas. Las más usadas son las que están en negrita, repasaremos la función apply pero no nos detendremos mucho porque muchas de estas no están al alcance del presente curso. 1.7.7 apply apply aplica una función a todos los elementos de una matriz. La estructura de esta función es la siguiente. apply(X, MARGIN, FUN) apply tiene tres argumentos: X: Una matriz o un objeto que pueda coercionarse a una matriz, generalmente, un data frame. MARGIN: La dimensión (margen) que agrupará los elementos de la matriz X, para aplicarles una función. Son identificadas con números, 1 son renglones y 2 son colummnas. FUN: La función que aplicaremos a la matriz X en su dimención MARGIN. Si queremos sumar todas las columnas de una matriz, podemos aplicar esta función, para comparar usaremos también la función ColSums() que realiza esta misma operación: matriz&lt;- matrix(1:20, ncol = 5, nrow = 4) matriz ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 5 9 13 17 ## [2,] 2 6 10 14 18 ## [3,] 3 7 11 15 19 ## [4,] 4 8 12 16 20 apply(X = matriz, MARGIN = 2, FUN = sum) ## [1] 10 26 42 58 74 colSums(matriz) ## [1] 10 26 42 58 74 También podemos aplicar múltiples funciones a una matriz: multiples.func &lt;- function(x) { c(sum = sum(x), prom = mean(x), max = max(x))} apply(X = matriz, MARGIN = 2, FUN = multiples.func) ## [,1] [,2] [,3] [,4] [,5] ## sum 10.0 26.0 42.0 58.0 74.0 ## prom 2.5 6.5 10.5 14.5 18.5 ## max 4.0 8.0 12.0 16.0 20.0 1.7.8 Estructuras de control Estas estructuras nos permiten controlar la manera en que se ejecuta nuestro código.Se establecen como condicionales en nuestros código. Por ejemplo, qué condiciones deben cumplirse para realizar una operación o qué debe ocurrir para ejecutar una función. Las estructuras de control más usadas son: Estructura de control Descripción if, else Si, de otro modo while mientras for Para break interrumpe next siguiente También las tocaremos pero no profundizaremos mucho en ellas, pero conoceremos como se utilizan. 1.7.8.1 If, else If y else se utilizan para crear condiciones, por ejemplo, si cumple esta condición entonces haz esto, de otra manera, haz esto. Ejemplo: if(10&gt;2) {&quot;Verdadero&quot; } else { &quot;Falso&quot; } ## [1] &quot;Verdadero&quot; if(10&lt;2) {&quot;Verdadero&quot; } else { &quot;Falso&quot; } ## [1] &quot;Falso&quot; También hay una función que reune estas dos condiciones, esifelse() y se usa de igual manera: ifelse((10&gt;2), &quot;Verdadero&quot;, &quot;Falso&quot;) ## [1] &quot;Verdadero&quot; Podemos aplicarlo en los data.frames usando como ejemplo el dataset anterior: ifelse(evaluaciones$notas&gt;7, &quot;Aprobado&quot;, &quot;Reprobado&quot;) ## [1] &quot;Aprobado&quot; &quot;Aprobado&quot; &quot;Reprobado&quot; 1.7.8.2 for La estructura for nos permite ejecutar un bucle (loop), realizando una operación para cada elemento de un conjunto de datos. Ejemplo: un_vector&lt;- 1:10 for(i in un_vector) { print(i*2) } ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 8 ## [1] 10 ## [1] 12 ## [1] 14 ## [1] 16 ## [1] 18 ## [1] 20 1.7.9 while Este es un tipo de bucle que ocurre mientras una condición es verdadera (TRUE). La operación se realiza hasta que se se llega a cumplir un criterio previamente establecido. Ejemplo: umbral &lt;- 3 valor &lt;- 0 while(valor &lt; umbral) { print(&quot;Aún no llegas al umbral&quot;) valor &lt;- valor + 1 } ## [1] &quot;Aún no llegas al umbral&quot; ## [1] &quot;Aún no llegas al umbral&quot; ## [1] &quot;Aún no llegas al umbral&quot; Para revisar las demás estructuras, podemos revisar la referencia citada8 1.7.10 Tratando con datos NA 1.7.10.1 1. Probando qué tenemos NA en nuestros datos: data &lt;- data.frame(x1 = c(NA, 5, 6, 8, 9), x2 = c(2, 4, NA, NA, 1), x3 = c(3,6,7,0,3), x4 = c(&quot;Hola&quot;, &quot;algo&quot;, NA, &quot;Chao&quot;, NA)) is.na(data) ## x1 x2 x3 x4 ## [1,] TRUE FALSE FALSE FALSE ## [2,] FALSE FALSE FALSE FALSE ## [3,] FALSE TRUE FALSE TRUE ## [4,] FALSE TRUE FALSE FALSE ## [5,] FALSE FALSE FALSE TRUE is.na(data$x2) ## [1] FALSE FALSE TRUE TRUE FALSE which(is.na(data)) ## [1] 1 8 9 18 20 sum(is.na(data)) ## [1] 5 1.7.10.2 2. Omitir NAs mean(data$x1, na.rm=TRUE) ## [1] 7 data[complete.cases(data),] ## x1 x2 x3 x4 ## 2 5 4 6 algo na.omit(data) ## x1 x2 x3 x4 ## 2 5 4 6 algo data[!is.na(data$x2),] ## x1 x2 x3 x4 ## 1 NA 2 3 Hola ## 2 5 4 6 algo ## 5 9 1 3 &lt;NA&gt; 1.7.10.3 3. Reemplazar NA’s #reemplazar con 0 data[is.na(data)] &lt;- 0 #reemplazar con el promedio o mediana data$x1[is.na(data$x1)] &lt;- mean(data$x1, na.rm = TRUE) data$x2[is.na(data$x2)] &lt;- median(data$x2, na.rm = TRUE) Para ver soluciones más complejas podemos buscar los paquetes Hmisc (impute), mice (mice) y rpart (repart). https://bookdown.org/ndphillips/YaRrr/arranging-plots-with-parmfrow-and-layout.html↩︎ https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html↩︎ https://cran.r-project.org/web/packages/egg/vignettes/Ecosystem.html↩︎ https://r-charts.com/es/miscelanea/↩︎ https://www.r-project.org/help.html↩︎ https://rafalab.github.io/dslibro/r-basics.html#↩︎ https://bookdown.org/ndphillips/YaRrr/arranging-plots-with-parmfrow-and-layout.html↩︎ https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html↩︎ "],["manejo-de-data-frames-y-bases-de-datos.html", "Capítulo 2 Manejo de data frames y bases de datos 2.1 Manipulación de datos con Rbase 2.2 Manejo de datos con tidyverse", " Capítulo 2 Manejo de data frames y bases de datos 2.1 Manipulación de datos con Rbase 2.1.1 Filtrado y obtención de subconjuntos En los capítulos anteriores ya vimos algunos ejemplos de subconjuntos y filtrados, retomaremos algunos de estos y también veremos unos nuevos. Para ejemplificar mejor esta parte, de nuevo trabajaremos con el dataset de ToothGrowth y utilizaré la función head() para ver solo las 6 primeras filas: data(&quot;ToothGrowth&quot;) 2.1.1.1 Seleccionando columnas head(ToothGrowth[1:2]) ## len supp ## 1 4.2 VC ## 2 11.5 VC ## 3 7.3 VC ## 4 5.8 VC ## 5 6.4 VC ## 6 10.0 VC head(ToothGrowth[-3]) ## len supp ## 1 4.2 VC ## 2 11.5 VC ## 3 7.3 VC ## 4 5.8 VC ## 5 6.4 VC ## 6 10.0 VC head(ToothGrowth[c(&quot;dose&quot;, &quot;len&quot;)]) ## dose len ## 1 0.5 4.2 ## 2 0.5 11.5 ## 3 0.5 7.3 ## 4 0.5 5.8 ## 5 0.5 6.4 ## 6 0.5 10.0 head(ToothGrowth[-1:-2,1:2]) ## len supp ## 3 7.3 VC ## 4 5.8 VC ## 5 6.4 VC ## 6 10.0 VC ## 7 11.2 VC ## 8 11.2 VC 2.1.1.2 Filtrando filas Tradicionalmente indexando podemos filtrar nuestra tabla usando: head(ToothGrowth[-1:-2,]) ## len supp dose ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10.0 VC 0.5 ## 7 11.2 VC 0.5 ## 8 11.2 VC 0.5 head(ToothGrowth[which(ToothGrowth$supp == &quot;VC&quot;),]) ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10.0 VC 0.5 ind&lt;-ToothGrowth$len&gt;27 ind2&lt;- ToothGrowth$sup==&quot;OJ&quot; head(ToothGrowth[ind,]) ## len supp dose ## 23 33.9 VC 2 ## 26 32.5 VC 2 ## 30 29.5 VC 2 ## 50 27.3 OJ 1 ## 56 30.9 OJ 2 ## 58 27.3 OJ 2 head(ToothGrowth[ind2,]) ## len supp dose ## 31 15.2 OJ 0.5 ## 32 21.5 OJ 0.5 ## 33 17.6 OJ 0.5 ## 34 9.7 OJ 0.5 ## 35 14.5 OJ 0.5 ## 36 10.0 OJ 0.5 Un detalle importante en los dataframes son la inserción de los llamados “NA” que son datos que no han sido introducidos por error o porque no se tienen los datos. En algunos análisis estos tipos de datos no son deseados porque pueden generar ruido por lo que se sugiere identificarlos, omitirlos y/o eliminarlos. Veamos un ejemplo: promedio_clases&lt;- data.frame(clase=c(&quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;), notas=c(7,8,9, 10, 9, NA)) mean(promedio_clases$notas) ## [1] NA Una opción que tenemos es colocar el argumento na.rm=TRUE para que nos ignore los NA’s la función: mean(promedio_clases$notas, na.rm=TRUE) ## [1] 8.6 Pero si queremos identificar cuales son los datos que nos dan NA y filtrarlos usamos la función is.na(): is.na(promedio_clases$notas) ## [1] FALSE FALSE FALSE FALSE FALSE TRUE Indexando podemos remover estos NA: promedio_clases[!is.na(promedio_clases$notas),] ## clase notas ## 1 M 7 ## 2 M 8 ## 3 M 9 ## 4 B 10 ## 5 B 9 También R tiene una función que nos hace más fácil esto: na.omit(promedio_clases) ## clase notas ## 1 M 7 ## 2 M 8 ## 3 M 9 ## 4 B 10 ## 5 B 9 2.1.1.3 Filtrando con subset() Hay una función en R básico que nos permite obtener subconjuntos o filtrar las filas de nuestras tablas de manera más intuitiva. Usaremos de nuevo la data de ToothGrowth: head(subset(ToothGrowth, dose==&quot;0.5&quot;)) ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10.0 VC 0.5 subset(ToothGrowth, dose==&quot;0.5&quot; &amp; supp ==&quot;OJ&quot; &amp; len &gt;10) ## len supp dose ## 31 15.2 OJ 0.5 ## 32 21.5 OJ 0.5 ## 33 17.6 OJ 0.5 ## 35 14.5 OJ 0.5 ## 39 16.5 OJ 0.5 2.1.2 Creando una nueva columna Para crear una nueva columna de una dataframe podemos utilizar varios métodos: - El primero sería declarar una variable nueva de la dataframe y de ahí indicarle que se desea como nueva columna en el dataframe utilizando el “$”. Creemos una data como la anterior de las notas: promedio_notas&lt;- data.frame(estudiante = c(&quot;E1&quot;, &quot;E2&quot;, &quot;E3&quot;,&quot;E1&quot;, &quot;E2&quot;, &quot;E3&quot;), clase=c(&quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;), notas=c(7,8,9, 10, 9, 8)) promedio_notas$ponderacion &lt;- c(0.7,0.7,0.7, 0.3,0.3,0.3) promedio_notas ## estudiante clase notas ponderacion ## 1 E1 M 7 0.7 ## 2 E2 M 8 0.7 ## 3 E3 M 9 0.7 ## 4 E1 B 10 0.3 ## 5 E2 B 9 0.3 ## 6 E3 B 8 0.3 - También podemos usar las funciones within() y transform(): promedio_notas&lt;-within(promedio_notas, nota_ponderada &lt;- notas*ponderacion) promedio_notas&lt;-transform(promedio_notas, nota_ponderada = notas*ponderacion) promedio_notas ## estudiante clase notas ponderacion nota_ponderada ## 1 E1 M 7 0.7 4.9 ## 2 E2 M 8 0.7 5.6 ## 3 E3 M 9 0.7 6.3 ## 4 E1 B 10 0.3 3.0 ## 5 E2 B 9 0.3 2.7 ## 6 E3 B 8 0.3 2.4 2.1.3 aggregate() : Resumiendo los datos Con la función aggregate() podemos resumir nuestros datos, por ejemplo: aggregate(notas ~ clase, data = promedio_notas, mean) ## clase notas ## 1 B 9 ## 2 M 8 aggregate(notas ~ estudiante, data = promedio_notas, median) ## estudiante notas ## 1 E1 8.5 ## 2 E2 8.5 ## 3 E3 8.5 aggregate(notas ~ clase+estudiante, data = promedio_notas, sum) ## clase estudiante notas ## 1 B E1 10 ## 2 M E1 7 ## 3 B E2 9 ## 4 M E2 8 ## 5 B E3 8 ## 6 M E3 9 2.1.4 Renombrando columnas y datos Para renombrar columnas podemo sólo reescribir el nuevo nombre por el viejo, por ejemplo: colnames(promedio_notas) ## [1] &quot;estudiante&quot; &quot;clase&quot; &quot;notas&quot; &quot;ponderacion&quot; &quot;nota_ponderada&quot; colnames(promedio_notas)[2] &lt;- &quot;curso&quot; colnames(promedio_notas) ## [1] &quot;estudiante&quot; &quot;curso&quot; &quot;notas&quot; &quot;ponderacion&quot; &quot;nota_ponderada&quot; También si queremos cambiar todos los nombres de las columnas (no lo correré pero dejaré el ejemplo): names(promedio_notas) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) 2.1.4.1 Renombrando valores en una columna: promedio_notas$curso &lt;- ifelse(promedio_notas$curso == &quot;M&quot;, &quot;Matemáticas&quot;, &quot;Biología&quot;) promedio_notas$curso ## [1] &quot;Matemáticas&quot; &quot;Matemáticas&quot; &quot;Matemáticas&quot; &quot;Biología&quot; &quot;Biología&quot; &quot;Biología&quot; 2.1.5 cbind() y rbind() cbind() y rbind() son funciones que nos permiten combinar y juntar vectores, matrices y tablas. “c” es para juntar por columnas (horizontalmente, una al lado de otra) y “r” para combinar combinar por filas (verticalmente, una abajo de otra). Ejemplos: cbind: correcion_nota&lt;- c(10,9,8,8,9,10) cbind(promedio_notas, correcion_nota) ## estudiante curso notas ponderacion nota_ponderada correcion_nota ## 1 E1 Matemáticas 7 0.7 4.9 10 ## 2 E2 Matemáticas 8 0.7 5.6 9 ## 3 E3 Matemáticas 9 0.7 6.3 8 ## 4 E1 Biología 10 0.3 3.0 8 ## 5 E2 Biología 9 0.3 2.7 9 ## 6 E3 Biología 8 0.3 2.4 10 cbind(promedio_notas, promedio_notas) ## estudiante curso notas ponderacion nota_ponderada estudiante curso notas ponderacion ## 1 E1 Matemáticas 7 0.7 4.9 E1 Matemáticas 7 0.7 ## 2 E2 Matemáticas 8 0.7 5.6 E2 Matemáticas 8 0.7 ## 3 E3 Matemáticas 9 0.7 6.3 E3 Matemáticas 9 0.7 ## 4 E1 Biología 10 0.3 3.0 E1 Biología 10 0.3 ## 5 E2 Biología 9 0.3 2.7 E2 Biología 9 0.3 ## 6 E3 Biología 8 0.3 2.4 E3 Biología 8 0.3 ## nota_ponderada ## 1 4.9 ## 2 5.6 ## 3 6.3 ## 4 3.0 ## 5 2.7 ## 6 2.4 rbind: notas_fisica&lt;- data.frame(estudiante = c(&quot;E1&quot;, &quot;E2&quot;, &quot;E3&quot;), curso=c(&quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;), notas=c(7, 9, 8)) rbind(promedio_notas, notas_fisica) Error in rbind(deparse.level, …) : numbers of columns of arguments do not match Vemos este error es debido a que tanto para hacer el cbind o el rbind se necesitan tener las mismas dimensiones entre objetos (tablas, vectores y matrices). Y en el caso del rbind, deben tener el mismo nombre de columnas (colnames). En este caso quería agregar unas filas abajo en esta tabla pero nos faltó la columna de ponderación, probemos de nuevo: notas_fisica&lt;- data.frame(estudiante = c(&quot;E1&quot;, &quot;E2&quot;, &quot;E3&quot;), curso=c(&quot;Fisica&quot;, &quot;Fisica&quot;, &quot;Fisica&quot;), notas=c(7, 9, 8), ponderacion = c(0.1, 0.1, 0.1), nota_ponderada= c(10, 9, 8)) rbind(promedio_notas, notas_fisica) ## estudiante curso notas ponderacion nota_ponderada ## 1 E1 Matemáticas 7 0.7 4.9 ## 2 E2 Matemáticas 8 0.7 5.6 ## 3 E3 Matemáticas 9 0.7 6.3 ## 4 E1 Biología 10 0.3 3.0 ## 5 E2 Biología 9 0.3 2.7 ## 6 E3 Biología 8 0.3 2.4 ## 7 E1 Fisica 7 0.1 10.0 ## 8 E2 Fisica 9 0.1 9.0 ## 9 E3 Fisica 8 0.1 8.0 2.1.6 Uniendo tablas con merge() Con la funcion merge() podemos unir dos dataframes con nombres de columnas y filas comunes: x &lt;- data.frame(k1 = c(1,3,3,4,5), k2 = c(&quot;a1&quot;,&quot;a2&quot;,&quot;a3&quot;,&quot;a4&quot;,&quot;a5&quot;), data = 1:5) y &lt;- data.frame(k3 = c(2,2,6,4,5), k2 = c(&quot;a1&quot;,&quot;a2&quot;,&quot;a3&quot;,&quot;a4&quot;,&quot;a5&quot;), data = 1:5) merge(x, y, by = &quot;k2&quot;) ## k2 k1 data.x k3 data.y ## 1 a1 1 1 2 1 ## 2 a2 3 2 2 2 ## 3 a3 3 3 6 3 ## 4 a4 4 4 4 4 ## 5 a5 5 5 5 5 merge(x, y, by = c(&quot;k2&quot;, &quot;data&quot;), all = TRUE) ## k2 data k1 k3 ## 1 a1 1 1 2 ## 2 a2 2 3 2 ## 3 a3 3 3 6 ## 4 a4 4 4 4 ## 5 a5 5 5 5 Vimos como se pueden unir tablas con columnas en común estas pueden ser una o más y preferiblemente que tengan nombres diferentes las columnas que no se van a unir. 2.1.7 Ordenando tablas por un criterio o columna Podemos ordenar nuestra tabla con uno o más criterios: promedio_notas &lt;- promedio_notas[order(promedio_notas$notas, decreasing = TRUE),] promedio_notas ## estudiante curso notas ponderacion nota_ponderada ## 4 E1 Biología 10 0.3 3.0 ## 3 E3 Matemáticas 9 0.7 6.3 ## 5 E2 Biología 9 0.3 2.7 ## 2 E2 Matemáticas 8 0.7 5.6 ## 6 E3 Biología 8 0.3 2.4 ## 1 E1 Matemáticas 7 0.7 4.9 promedio_notas &lt;- promedio_notas[order(promedio_notas$notas, promedio_notas$ponderacion),] promedio_notas ## estudiante curso notas ponderacion nota_ponderada ## 1 E1 Matemáticas 7 0.7 4.9 ## 6 E3 Biología 8 0.3 2.4 ## 2 E2 Matemáticas 8 0.7 5.6 ## 5 E2 Biología 9 0.3 2.7 ## 3 E3 Matemáticas 9 0.7 6.3 ## 4 E1 Biología 10 0.3 3.0 2.1.8 Funciones adicionales de agregación para calcular fácilmente los promedos o sumas de todas las columnas y las filas usamos rowMeans(), colMeans(), rowSums() y colSums(). examen &lt;- data.frame(&quot;q1&quot; = c(1, 0, 0, 0, 0), &quot;q2&quot; = c(1, 0, 1, 1, 0), &quot;q3&quot; = c(1, 0, 1, 0, 0), &quot;q4&quot; = c(1, 1, 1, 1, 1), &quot;q5&quot; = c(1, 0, 0, 1, 1)) rowMeans(examen) ## [1] 1.0 0.2 0.6 0.6 0.4 colMeans(examen) ## q1 q2 q3 q4 q5 ## 0.2 0.6 0.4 1.0 0.6 rowSums(examen) ## [1] 5 1 3 3 2 colSums(examen) ## q1 q2 q3 q4 q5 ## 1 3 2 5 3 También si queremos saber cuántas columnas y filas tienen nuestros datos además de dim() y str() podemos usar: nrow(examen) ## [1] 5 ncol(examen) ## [1] 5 2.1.9 Ejemplo aplicado9 Las siguientes dos tablas muestran los resultados de dos encuestas hechas a 10 personas. En la primera encuesta preguntaron su género y su edad. Y en la segunda preguntaron su superhéroe favorito y cantidad de tatuajes que tenía. primera&lt;- data.frame(Nombre= c(&quot;Astrid&quot;, &quot;Lea&quot;, &quot;Sarina&quot;, &quot;Remon&quot;, &quot;Letizia&quot;, &quot;Babice&quot;, &quot;Jonas&quot;, &quot;Wendy&quot;, &quot;Nivedithia&quot;, &quot;Gioia&quot;), Sexo= c(&quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;), Edad= c(30,25,25,29,22,22,35,19,32,21)) segunda&lt;- data.frame(Nombre= c(&quot;Astrid&quot;, &quot;Lea&quot;, &quot;Sarina&quot;, &quot;Remon&quot;, &quot;Letizia&quot;, &quot;Babice&quot;, &quot;Jonas&quot;, &quot;Wendy&quot;, &quot;Nivedithia&quot;, &quot;Gioia&quot;), Superhéroe= c(&quot;Batman&quot;, &quot;Superman&quot;, &quot;Batman&quot;, &quot;Spiderman&quot;, &quot;Batman&quot;, &quot;Antman&quot;, &quot;Batman&quot;, &quot;Superman&quot;, &quot;Maggot&quot;, &quot;Superman&quot;), Tatuajes= c(11,15,12,5,65,3,9,13,900,0)) knitr::kable(primera); knitr::kable(segunda) Nombre Sexo Edad Astrid F 30 Lea F 25 Sarina F 25 Remon M 29 Letizia F 22 Babice F 22 Jonas M 35 Wendy F 19 Nivedithia F 32 Gioia F 21 Nombre Superhéroe Tatuajes Astrid Batman 11 Lea Superman 15 Sarina Batman 12 Remon Spiderman 5 Letizia Batman 65 Babice Antman 3 Jonas Batman 9 Wendy Superman 13 Nivedithia Maggot 900 Gioia Superman 0 Para hacer: Combina las dos tablas en una sola y completa las siguientes asignaciones. ¿Cuál es la edad media de las mujeres y hombres por separado? ¿Cuál fue el número más alto de tatuajes en un hombre? ¿Cuál es el porcentaje de personas debajo de 32 años que son mujeres? Agrega una nueva columna a a la data llamada tatuajes.por.año que muestre cuántos tatuajes por año se ha hecho cada persona por cada año en su vida. ¿Cuál persona tiene el mayor número de tatuajes por año? ¿Cuáles son los nombres de las mujeres a las que su superheroe favorito es superman? ¿Cuál es la mediana del número de tatuajes de cad apersona que está por encima de los 20 años y que su personaje favorito es Batman? 2.1.9.1 Resolviendo Combina las dos tablas en una sola y completa las siguientes asignaciones. encuestas&lt;- merge(primera, segunda, by = &quot;Nombre&quot;) 2. ¿Cuál es la edad media de las mujeres y hombres por separado? cómo podemos hacer esto? aggregate(Edad ~ Sexo, data = encuestas, mean) ## Sexo Edad ## 1 F 24.5 ## 2 M 32.0 3. ¿Cuál fue el número más alto de tatuajes en un hombre? males&lt;- subset(encuestas, Sexo==&quot;M&quot;) max(males$Tatuajes) ## [1] 9 4. ¿Cuál es el porcentaje de mujeres debajo de 32 años? fem&lt;- subset(encuestas, Sexo==&quot;F&quot;) fem_32&lt;- fem[fem$Edad&lt;32,] (nrow(fem_32)/nrow(fem))*100 ## [1] 87.5 5. Agrega una nueva columna a a la data llamada tatuajes.por.año que muestre cuántos tatuajes por año se ha hecho cada persona por cada año en su vida. encuestas$tatuajes.por.año&lt;- encuestas$Tatuajes/encuestas$Edad encuestas$tatuajes.por.año ## [1] 0.3666667 0.1363636 0.0000000 0.2571429 0.6000000 2.9545455 28.1250000 0.1724138 0.4800000 ## [10] 0.6842105 6. ¿Cuál persona tiene el mayor número de tatuajes por año? mayor_tatuaje&lt;-which.max(encuestas$tatuajes.por.año) encuestas[mayor_tatuaje,] ## Nombre Sexo Edad Superhéroe Tatuajes tatuajes.por.año ## 7 Nivedithia F 32 Maggot 900 28.125 7. ¿Cuáles son los nombres de las mujeres a las que su superheroe favorito es superman? sup&lt;-fem[fem$Superhéroe==&quot;Superman&quot;,] sup$Nombre ## [1] &quot;Gioia&quot; &quot;Lea&quot; &quot;Wendy&quot; 8. ¿Cuál es la mediana del número de tatuajes de cada persona que está por encima de los 20 años y que su personaje favorito es superman? ocho&lt;- subset(encuestas, Edad&gt;20 &amp; Superhéroe ==&quot;Batman&quot;) median(ocho$Tatuajes) ## [1] 11.5 2.2 Manejo de datos con tidyverse 2.2.1 tidyverse Hasta ahora hemos estado manipulando las tablas o dataframes creando subconjuntos mediante la indexación y utlizando otras funciones del Rbase. Sin embargo, existe todo un universo llamado tidyverse que nos perimte hacer todo esto que vimos y más de manera más intuitiva. Podemos cargar todos los paquetes del tidyverse a la vez al instalar y cargar el paquete tidyverse: library(tidyverse) Los paquetes que se activan son dplyr, purr, tidyr, stringr, tibble para el manejo de tablas; readr para importar y exportar datos y forcats para manejo de factores. Además de ggplot2 que es el paquete para graficar. 2.2.2 Datos tidy Hemos estado trabajando con tablas o dataframes, sin embargo, el tidyverse presenta un nuevo tipo de forma de almacenamiento de datos. Decimos que una tabla de datos está en formato tidy si cada fila representa una observación y las columnas representan las diferentes variables disponibles para cada una de estas observaciones. El set de datos us_rent_income o como lo he denominado rentas_us es un ejemplo de un data frame tidy. estado variable estimado Alabama ingreso 24476 Alabama renta 747 Alaska ingreso 32940 Alaska renta 1200 Arizona ingreso 27517 Arizona renta 972 Arkansas ingreso 23789 Arkansas renta 709 California ingreso 29454 California renta 1358 Cada fila representa una medida con cada una de las otras dos columnas proveyendo una variable diferente relacionada con las otras dos: variable (si es el ingreso o la renta) y el estado. Ahora bien, también podemos ver la misma información pero organizada de otra forma: estado ingreso renta Alabama 24476 747 Alaska 32940 1200 Arizona 27517 972 Arkansas 23789 709 California 29454 1358 Se provee la misma información, pero hay dos diferencias importantes en el formato: 1) cada fila incluye varias observaciones y 2) una de las variables, “variable”, se almacena en el encabezado. Para que los paquetes del tidyverse se utilicen de manera óptima, le tenemos que cambiar la forma a los datos para que estén en formato tidy, como las primera tabla. Esto podemos hacerlo fuera de R o también R tiene funciones para hacerlo, que veremos más adelante. 2.2.2.1 Tibbles Los datos o tablas resultantes luego de aplicar funciones del tidyverse se conocen como tibbles y son prácticamente igual que los dataframes pero con unas ligeras diferencias. Veamos: df&lt;- data.frame(letras=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), números=1:3) tib&lt;- as_tibble(df) class(df) ## [1] &quot;data.frame&quot; class(tib) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; print(df) ## letras números ## 1 a 1 ## 2 b 2 ## 3 c 3 print(tib) ## # A tibble: 3 × 2 ## letras números ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 Se ven ligeramente diferentes, como que la tibble te muestra información como tipo de dato de columna y las dimensiones, además de omitir los rownames por defecto. Algunas funciones pueden dar error si no es de un tipo u otro, por ejemplo si en vez de ser un dataframe es un tibble pero en escencia son lo mismo y se manejan igual. De aquí en adelante nos dirijiremos indistintamente sobre las dos, aunque ya sabemos la diferencia entre una y otra. 2.2.3 Manipulación de data frames El paquete dplyr del tidyverse ofrece funciones que realizan algunas de las operaciones más comunes y que ya vimos el capítulo anterior con R base. Las funciones principales de dplyr son: select, mutate, filter y summarise. Pero antes, revisemos lo que es el pipe. 2.2.4 El pipe: %&gt;% El pipe es la herramienta que nos permite darle dplyr las órdenes, comandos o funciones a realizar. Lo podemos poner con el atajo del teclado “Ctrl + Shift + M (Windows/linux)” y “Cmd + Shift + M (Mac)”. Con dplyr, podemos realizar una serie de operaciones, por escoger una columna, crear una nueva, filtrar nuestras filas y demás . En Rbase tendríamos que hacer paso por paso, por ejemplo : #asignando la data a la variable &quot;mi_data&quot; mi_data&lt;-ToothGrowth head(mi_data) ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10.0 VC 0.5 #escoger sólo las columnas len y dose mi_data&lt;- mi_data[c(&quot;len&quot;, &quot;dose&quot;)] head(mi_data) ## len dose ## 1 4.2 0.5 ## 2 11.5 0.5 ## 3 7.3 0.5 ## 4 5.8 0.5 ## 5 6.4 0.5 ## 6 10.0 0.5 #hacer una nueva columna declarando la variable &quot;dose&quot; como un factor mi_data$dose&lt;- factor(mi_data$dose, levels = c(0.5,1.0, 2.0), labels =c(&quot;D0.5&quot;, &quot;D1&quot;, &quot;2&quot;)) head(mi_data) ## len dose ## 1 4.2 D0.5 ## 2 11.5 D0.5 ## 3 7.3 D0.5 ## 4 5.8 D0.5 ## 5 6.4 D0.5 ## 6 10.0 D0.5 #filtrar solo los que sean de dosis = 1 mi_data&lt;- mi_data[mi_data$dose==&quot;D1&quot;,] head(mi_data) ## len dose ## 11 16.5 D1 ## 12 16.5 D1 ## 13 15.2 D1 ## 14 17.3 D1 ## 15 22.5 D1 ## 16 17.3 D1 En cambio en dplyr y con funciones que veremos a continuación, todos estos pasos podemos resumirlos a la siguiente línea de código: mi_data&lt;- ToothGrowth %&gt;% select(len, dose) %&gt;% mutate( dose=case_when(dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% filter(dose==&quot;D1&quot;) head(mi_data) ## len dose ## 1 16.5 D1 ## 2 16.5 D1 ## 3 15.2 D1 ## 4 17.3 D1 ## 5 22.5 D1 ## 6 17.3 D1 Como vimos para realizar la secuencia de estos pasos y unir estas funciones en una sólo línea de código hicimos uso del pipe %&gt;%. En general, el pipe envía el resultado que se encuentra en el lado izquierdo del pipe para ser el primer argumento de la función en el lado derecho del pipe. Aquí vemos un ejemplo sencillo: 16 %&gt;% sqrt() ## [1] 4 Podemos continuar canalizando (piping en inglés) valores a lo largo de: 16 %&gt;% sqrt() %&gt;% log2() ## [1] 2 La declaración anterior es equivalente a: log2(sqrt(16)) ## [1] 2 Ahora veremos todas las funciones que nos permitirán manipular nuestras tablas en el mismo orden que las vimos en Rbase (el capítulo pasado). 2.2.5 Seleccionando columnas dplyr tiena una función muy intuitiva para seleccionar las columnas que queremos en un dataframe y es select() head(select(.data = ToothGrowth, len, dose)) ## len dose ## 1 4.2 0.5 ## 2 11.5 0.5 ## 3 7.3 0.5 ## 4 5.8 0.5 ## 5 6.4 0.5 ## 6 10.0 0.5 Usandola con el pipe sería algo así: #seleccionando columnas que queremos ToothGrowth %&gt;% select(len, dose) %&gt;% head() ## len dose ## 1 4.2 0.5 ## 2 11.5 0.5 ## 3 7.3 0.5 ## 4 5.8 0.5 ## 5 6.4 0.5 ## 6 10.0 0.5 ToothGrowth %&gt;% select(len:dose) %&gt;% glimpse() ## Rows: 60 ## Columns: 3 ## $ len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.3… ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… #Seleccionando columnas que no queremos ToothGrowth %&gt;% select(-len) %&gt;% glimpse() ## Rows: 60 ## Columns: 2 ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… La función glimpse nos permite ver los datos como la función str pero uniendolo al pipe. También podemos seleccionar columnas con criterios, por ejemplo: ToothGrowth %&gt;% select(starts_with(&quot;d&quot;)) %&gt;% glimpse() ## Rows: 60 ## Columns: 1 ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… ToothGrowth %&gt;% select(contains(&quot;ose&quot;)) %&gt;% glimpse() ## Rows: 60 ## Columns: 1 ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… ToothGrowth %&gt;% select(ends_with(&quot;ose&quot;)) %&gt;% glimpse() ## Rows: 60 ## Columns: 1 ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… ToothGrowth %&gt;% select(matches(&quot;o.+e&quot;)) %&gt;% glimpse() ## Rows: 60 ## Columns: 1 ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… Seleccionando usando un vector, notemos también que en el orden que ponemos el vector así va a apareciendo reordenando las columnas en nuestra tabla: colum &lt;- c(&quot;supp&quot;, &quot;len&quot;) ToothGrowth %&gt;% select(!!colum) %&gt;% glimpse() ## Rows: 60 ## Columns: 2 ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ## $ len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.3… Cada función del tidyverse tiene tres variantes que son at, if y all que al combinarlos con nuestras funciones principales como select nos permiten hacer muchas cosas más. Por ejemplo, si usamos if sería bajo un criterio como un tipo de dato : #selección positiva ToothGrowth %&gt;% select_if(is.numeric) %&gt;% glimpse() ## Rows: 60 ## Columns: 2 ## $ len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.3… ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… #selección negativa ToothGrowth %&gt;% select_if(~!is.numeric(.)) %&gt;% glimpse() ## Rows: 60 ## Columns: 1 ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … Con all podemos reformatear los nombres de nuestras columnas: ToothGrowth %&gt;% select_all(toupper) %&gt;% glimpse() ## Rows: 60 ## Columns: 3 ## $ LEN &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.3… ## $ SUPP &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ## $ DOSE &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… Y con at también podemos escoger columnas basadas en criterios, por ejemplo: #npositiva ToothGrowth%&gt;% select_at(vars(contains(&quot;ose&quot;))) %&gt;% glimpse() ## Rows: 60 ## Columns: 1 ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… #negativa ToothGrowth%&gt;% select_at(vars(-contains(&quot;ose&quot;))) %&gt;% glimpse() ## Rows: 60 ## Columns: 2 ## $ len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.3… ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ToothGrowth%&gt;% select_at(vars(!contains(&quot;ose&quot;))) %&gt;% glimpse() ## Rows: 60 ## Columns: 2 ## $ len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.3… ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … 2.2.6 Filtrando filas Para filtrar nuestra data a nivel de filas usamos la función filter: head(filter(ToothGrowth, supp==&quot;OJ&quot;) ) ## len supp dose ## 1 15.2 OJ 0.5 ## 2 21.5 OJ 0.5 ## 3 17.6 OJ 0.5 ## 4 9.7 OJ 0.5 ## 5 14.5 OJ 0.5 ## 6 10.0 OJ 0.5 o con el pipe: ToothGrowth %&gt;% filter(supp==&quot;OJ&quot;) %&gt;% glimpse() ## Rows: 30 ## Columns: 3 ## $ len &lt;dbl&gt; 15.2, 21.5, 17.6, 9.7, 14.5, 10.0, 8.2, 9.4, 16.5, 9.7, 19.7, 23.3, 23.6, 26.4, 20.0, 25… ## $ supp &lt;fct&gt; OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, OJ, … ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… ToothGrowth %&gt;% filter(len&gt;30) %&gt;% glimpse() ## Rows: 3 ## Columns: 3 ## $ len &lt;dbl&gt; 33.9, 32.5, 30.9 ## $ supp &lt;fct&gt; VC, VC, OJ ## $ dose &lt;dbl&gt; 2, 2, 2 ToothGrowth %&gt;% filter(supp==&quot;OJ&quot;, len&gt;30) %&gt;% glimpse() ## Rows: 1 ## Columns: 3 ## $ len &lt;dbl&gt; 30.9 ## $ supp &lt;fct&gt; OJ ## $ dose &lt;dbl&gt; 2 Filtrando basado en un vector: len_quiero&lt;-c(26.4, 27.3 ,29.4, 23.0) ToothGrowth %&gt;% filter(len %in% len_quiero) %&gt;% glimpse() ## Rows: 8 ## Columns: 3 ## $ len &lt;dbl&gt; 26.4, 26.4, 27.3, 26.4, 26.4, 27.3, 29.4, 23.0 ## $ supp &lt;fct&gt; VC, OJ, OJ, OJ, OJ, OJ, OJ, OJ ## $ dose &lt;dbl&gt; 2, 1, 1, 2, 2, 2, 2, 2 ToothGrowth %&gt;% filter(!len %in% len_quiero) %&gt;% glimpse() ## Rows: 52 ## Columns: 3 ## $ len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.3… ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ## $ dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… Filtrando NA’s (en caso de que este dataset tuviera NA’s): ToothGrowth %&gt;% filter(!is.na(len)) En el caso de if , all y at , nos permiten filtrar con condiciones y a través de varias columnas: ToothGrowth %&gt;% filter_if(is.numeric, all_vars(between(.,2,20))) ## len supp dose ## 1 18.5 VC 2 ToothGrowth %&gt;% filter_all(any_vars(. &gt; 30)) ## Warning: There was 1 warning in `filter()`. ## ℹ In argument: `len &gt; 30 | supp &gt; 30 | dose &gt; 30`. ## Caused by warning in `Ops.factor()`: ## ! &#39;&gt;&#39; not meaningful for factors ## len supp dose ## 1 33.9 VC 2 ## 2 32.5 VC 2 ## 3 30.9 OJ 2 ToothGrowth %&gt;% filter_at(vars(len, dose), all_vars(.&gt;1)) %&gt;% head() ## len supp dose ## 1 23.6 VC 2 ## 2 18.5 VC 2 ## 3 33.9 VC 2 ## 4 25.5 VC 2 ## 5 26.4 VC 2 ## 6 32.5 VC 2 2.2.7 Creando una nueva columna Para crear una nueva columna en dplyr usamos la función mutate(): ToothGrowth %&gt;% mutate(lenlog = log(len)) %&gt;% head() ## len supp dose lenlog ## 1 4.2 VC 0.5 1.435085 ## 2 11.5 VC 0.5 2.442347 ## 3 7.3 VC 0.5 1.987874 ## 4 5.8 VC 0.5 1.757858 ## 5 6.4 VC 0.5 1.856298 ## 6 10.0 VC 0.5 2.302585 Al igual que las funciones pasadas también podemos utilizar if, all y at: ToothGrowth %&gt;% mutate_if(is.numeric, round) %&gt;% head() ## len supp dose ## 1 4 VC 0 ## 2 12 VC 0 ## 3 7 VC 0 ## 4 6 VC 0 ## 5 6 VC 0 ## 6 10 VC 0 ToothGrowth %&gt;% mutate_all(tolower) %&gt;% head() ## len supp dose ## 1 4.2 vc 0.5 ## 2 11.5 vc 0.5 ## 3 7.3 vc 0.5 ## 4 5.8 vc 0.5 ## 5 6.4 vc 0.5 ## 6 10 vc 0.5 La acción de mutar o la función que se pone después del argumento (como round y tolower), muchas veces se pone sin paréntesis pero otras las requiere. Vemos también que usando el mutate_all cambia todas las columnas (lo que quiere decir que las numéricas las convierte en character). Ahora si quisieramos usarla al revés: ToothGrowth %&gt;% mutate_all(round) %&gt;% head() Error: Problem with mutate() column supp En estos casos es mejor usar if, como vimos en el ejemplo anterior, all aplica mejor si tenemos una data con el mismo tipo de datos (números, caracterres, factores). Ahora bien, at nos permite hacer cambios a columnas específicas: ToothGrowth %&gt;% mutate_at(vars(contains(&quot;ose&quot;)), ~(.*100)) %&gt;% head() ## len supp dose ## 1 4.2 VC 50 ## 2 11.5 VC 50 ## 3 7.3 VC 50 ## 4 5.8 VC 50 ## 5 6.4 VC 50 ## 6 10.0 VC 50 ToothGrowth %&gt;% mutate_at(&quot;dose&quot;, ~(.*100)) %&gt;% head() ## len supp dose ## 1 4.2 VC 50 ## 2 11.5 VC 50 ## 3 7.3 VC 50 ## 4 5.8 VC 50 ## 5 6.4 VC 50 ## 6 10.0 VC 50 2.2.8 Datos discretos Existen varias herramientas que nos sirven para trabajar con datos discretos, por ejemplo si queremos cambiar los datos de una columna y modificarlos: ToothGrowth %&gt;% mutate(supp2 = recode_factor(supp, &quot;OJ&quot; = &quot;Jugo&quot;, &quot;VC&quot; = &quot;Ascórbico&quot;, .default = &quot;other&quot;, .ordered = TRUE)) %&gt;% tail() ## len supp dose supp2 ## 55 24.8 OJ 2 Jugo ## 56 30.9 OJ 2 Jugo ## 57 26.4 OJ 2 Jugo ## 58 27.3 OJ 2 Jugo ## 59 29.4 OJ 2 Jugo ## 60 23.0 OJ 2 Jugo Otra cosa que podemos hacer es crear una nueva columna con valores discretos usando valores numéricos, por ejemplo: ToothGrowth%&gt;% mutate(dose2 = ifelse(dose &gt; 1, &quot;alto&quot;, &quot;bajo&quot;)) %&gt;% head() ## len supp dose dose2 ## 1 4.2 VC 0.5 bajo ## 2 11.5 VC 0.5 bajo ## 3 7.3 VC 0.5 bajo ## 4 5.8 VC 0.5 bajo ## 5 6.4 VC 0.5 bajo ## 6 10.0 VC 0.5 bajo Y si queremos renombrar los datos en una columna, entonces: ToothGrowth%&gt;%mutate(dose = case_when( dose == 0.5 ~ &quot;D_0.5&quot;, dose == 1 ~ &quot;D_1&quot;, dose == 2 ~ &quot;D_2&quot;)) %&gt;% mutate( dose = factor(dose, levels = c(&quot;D_2&quot;, &quot;D_1&quot;, &quot;D_0.5&quot;))) %&gt;% head() ## len supp dose ## 1 4.2 VC D_0.5 ## 2 11.5 VC D_0.5 ## 3 7.3 VC D_0.5 ## 4 5.8 VC D_0.5 ## 5 6.4 VC D_0.5 ## 6 10.0 VC D_0.5 Para separar o unir datos de una columna con data discreta (caracter), podemos usar las funciones unite() y separate(), por ejemplo: ToothGrowth %&gt;% unite(&quot;interaccion&quot;, supp:dose, sep = &quot;_&quot;) %&gt;% head() ## len interaccion ## 1 4.2 VC_0.5 ## 2 11.5 VC_0.5 ## 3 7.3 VC_0.5 ## 4 5.8 VC_0.5 ## 5 6.4 VC_0.5 ## 6 10.0 VC_0.5 Para ejemplifcar separate usaremos el ejemplo anterior: ToothGrowth%&gt;%mutate(dose = case_when( dose == 0.5 ~ &quot;D_0.5&quot;, dose == 1 ~ &quot;D_1&quot;, dose == 2 ~ &quot;D_2&quot;)) %&gt;% separate(dose, c(&quot;D&quot;, &quot;dose&quot;), sep = &quot;_&quot;) %&gt;% head() ## len supp D dose ## 1 4.2 VC D 0.5 ## 2 11.5 VC D 0.5 ## 3 7.3 VC D 0.5 ## 4 5.8 VC D 0.5 ## 5 6.4 VC D 0.5 ## 6 10.0 VC D 0.5 2.2.9 Resumiendo los datos Hay varias funciones en tidyverse que nos permiten hacer un resumen de nuestros datos, como por ejemplo la función count(): ToothGrowth %&gt;% count(supp, sort=TRUE) ## supp n ## 1 OJ 30 ## 2 VC 30 ToothGrowth %&gt;% count(dose, supp, sort=TRUE) ## dose supp n ## 1 0.5 OJ 10 ## 2 0.5 VC 10 ## 3 1.0 OJ 10 ## 4 1.0 VC 10 ## 5 2.0 OJ 10 ## 6 2.0 VC 10 Otra forma es usar group_by() que nos permite agrupar nuestros datos bajo alguna condición y luego aplicar una función a estos: ToothGrowth %&gt;% group_by(supp) %&gt;%count() ## # A tibble: 2 × 2 ## # Groups: supp [2] ## supp n ## &lt;fct&gt; &lt;int&gt; ## 1 OJ 30 ## 2 VC 30 Con este group_by() podemos aplicar cualquier cantidad de funciones, por ejemplo para en vez que me de el conteo me de el promedio, mediana, cuenta, suma, etc; para esto, debemos ocupar una nueva función muy útil llamada summarise(): ToothGrowth %&gt;% group_by(supp) %&gt;% summarise(promedio = mean(len), suma = sum(len), n = n(), mediana =median(len)) ## # A tibble: 2 × 5 ## supp promedio suma n mediana ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 OJ 20.7 620. 30 22.7 ## 2 VC 17.0 509. 30 16.5 Esta función también viene en todas las presentaciones, es decir, at, if y all, Ejemplos: ToothGrowth %&gt;% group_by(supp) %&gt;% summarise_if(is.numeric, mean) ## # A tibble: 2 × 3 ## supp len dose ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 OJ 20.7 1.17 ## 2 VC 17.0 1.17 ToothGrowth%&gt;% group_by(supp) %&gt;% summarise_at(vars(contains(&quot;ose&quot;)), mean) ## # A tibble: 2 × 2 ## supp dose ## &lt;fct&gt; &lt;dbl&gt; ## 1 OJ 1.17 ## 2 VC 1.17 ToothGrowth %&gt;% group_by(supp) %&gt;% summarise_all(mean) ## # A tibble: 2 × 3 ## supp len dose ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 OJ 20.7 1.17 ## 2 VC 17.0 1.17 2.2.10 Renombrando columnas Con tidyverse Existen diferentes formas de renombrar las columnas una es con la función select(): ToothGrowth %&gt;% select(dosis=dose, longitud=len, suplemento=supp) %&gt;% glimpse() ## Rows: 60 ## Columns: 3 ## $ dosis &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.… ## $ longitud &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5… ## $ suplemento &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC… También existe la función rename en todas sus versiones, ejemplos: ToothGrowth %&gt;% rename(dosis=dose) %&gt;% glimpse() ## Rows: 60 ## Columns: 3 ## $ len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.… ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC,… ## $ dosis &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.… ToothGrowth %&gt;% rename_if(is.numeric, ~paste0(&quot;Num_&quot;, .)) %&gt;% glimpse() ## Rows: 60 ## Columns: 3 ## $ Num_len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, … ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ## $ Num_dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,… ToothGrowth%&gt;% rename_at(vars(contains(&quot;ose&quot;)), ~paste0(&quot;Num_&quot;, .)) %&gt;% glimpse() ## Rows: 60 ## Columns: 3 ## $ len &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, … ## $ supp &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ## $ Num_dose &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,… ToothGrowth%&gt;% rename_all(toupper) %&gt;% glimpse() ## Rows: 60 ## Columns: 3 ## $ LEN &lt;dbl&gt; 4.2, 11.5, 7.3, 5.8, 6.4, 10.0, 11.2, 11.2, 5.2, 7.0, 16.5, 16.5, 15.2, 17.3, 22.5, 17.3… ## $ SUPP &lt;fct&gt; VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, VC, … ## $ DOSE &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0… 2.2.11 Ordenando tablas por un criterio o columna Conocemos las funciones order y sort, pero para ordenar tablas enteras, la función arrange de dplyr es útil. Por ejemplo: ToothGrowth %&gt;% arrange(len) %&gt;% head() ## len supp dose ## 1 4.2 VC 0.5 ## 2 5.2 VC 0.5 ## 3 5.8 VC 0.5 ## 4 6.4 VC 0.5 ## 5 7.0 VC 0.5 ## 6 7.3 VC 0.5 ToothGrowth %&gt;% arrange(-len) %&gt;% head() ## len supp dose ## 1 33.9 VC 2 ## 2 32.5 VC 2 ## 3 30.9 OJ 2 ## 4 29.5 VC 2 ## 5 29.4 OJ 2 ## 6 27.3 OJ 1 También podemos ordenar por varios criterios: ToothGrowth%&gt;% arrange(dose, supp) %&gt;% head() ## len supp dose ## 1 15.2 OJ 0.5 ## 2 21.5 OJ 0.5 ## 3 17.6 OJ 0.5 ## 4 9.7 OJ 0.5 ## 5 14.5 OJ 0.5 ## 6 10.0 OJ 0.5 2.2.12 Uniendo tablas Para la unión de tablas usaremos una familia de funciones denominadas joins. Las diferentes presentaciones de esta función nos permite juntar tablas: - inner_join() : incluye todas las filas en x y y (es decir la inteserccion o las que comparten). left_join(): incluye todas las filas en x. right_join(): incuye todas las filas en y. full_join(): incluye todas las filas en x o y (este incluye todos, incluso las que no comparten) band_members; band_instruments ## # A tibble: 3 × 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles ## # A tibble: 3 × 2 ## name plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar band_members %&gt;% full_join(band_instruments) ## Joining with `by = join_by(name)` ## # A tibble: 4 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass ## 4 Keith &lt;NA&gt; guitar band_members %&gt;% inner_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 2 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass band_members %&gt;% left_join(band_instruments) ## Joining with `by = join_by(name)` ## # A tibble: 3 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass band_members %&gt;% right_join(band_instruments) ## Joining with `by = join_by(name)` ## # A tibble: 3 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass ## 3 Keith &lt;NA&gt; guitar 2.2.13 Funciones adicionales del tydiverse Anteriormente, usamos la función head para evitar que la página se llene con todo el set de datos. Si queremos ver una mayor proporción, podemos usar la función top_n. Esta función toma un data frame como primer argumento, el número de filas para mostrar en el segundo y la variable para filtrar en el tercero. Aquí hay un ejemplo de cómo ver las 5 filas superiores: ToothGrowth %&gt;% top_n(5, len) ## len supp dose ## 1 33.9 VC 2 ## 2 32.5 VC 2 ## 3 29.5 VC 2 ## 4 30.9 OJ 2 ## 5 29.4 OJ 2 También hay otras funciones que son útiles en los diferentes análisis donde a veces ocupamos los rownames o a veces no, estas funciones nos permiten hacer una columna que sea rownames y viceversa, por ejemplo: ToothGrowth %&gt;% rownames_to_column(var = &quot;row&quot;) %&gt;% head() ## row len supp dose ## 1 1 4.2 VC 0.5 ## 2 2 11.5 VC 0.5 ## 3 3 7.3 VC 0.5 ## 4 4 5.8 VC 0.5 ## 5 5 6.4 VC 0.5 ## 6 6 10.0 VC 0.5 ToothGrowth %&gt;% rownames_to_column( var = &quot;row&quot;) %&gt;% column_to_rownames(var = &quot;row&quot;) %&gt;% head() ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10.0 VC 0.5 Si queremos convertir las tablas como al principio del capítulo, es decir, convertir una tabla que no está en formato tidy a una que sí esté y viceversa podemos usar las funciones pivot_longer() y pivot_wider() (antes denominadas gather() y spread(), pero ya están reemplazadas aunque aún no eliminadas). data(iris) data_iris&lt;- iris %&gt;% select(Sepal.Length, Sepal.Width) %&gt;% rownames_to_column(var = &quot;ids&quot;) head(data_iris) ## ids Sepal.Length Sepal.Width ## 1 1 5.1 3.5 ## 2 2 4.9 3.0 ## 3 3 4.7 3.2 ## 4 4 4.6 3.1 ## 5 5 5.0 3.6 ## 6 6 5.4 3.9 Vamos a cambiarla a formato tidy: tidy_iris&lt;-pivot_longer(names_to = &quot;variable&quot;, values_to = &quot;longitud&quot;, data = data_iris, cols = Sepal.Length:Sepal.Width) head(tidy_iris) ## # A tibble: 6 × 3 ## ids variable longitud ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 Sepal.Length 5.1 ## 2 1 Sepal.Width 3.5 ## 3 2 Sepal.Length 4.9 ## 4 2 Sepal.Width 3 ## 5 3 Sepal.Length 4.7 ## 6 3 Sepal.Width 3.2 Y si queremos regresar a como lo teníamos: notidy_iris&lt;- tidy_iris %&gt;% pivot_wider(names_from = variable, values_from = longitud) head(notidy_iris) ## # A tibble: 6 × 3 ## ids Sepal.Length Sepal.Width ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 5.1 3.5 ## 2 2 4.9 3 ## 3 3 4.7 3.2 ## 4 4 4.6 3.1 ## 5 5 5 3.6 ## 6 6 5.4 3.9 2.2.14 Ejemplo Aplicado primera&lt;- data.frame(Nombre= c(&quot;Astrid&quot;, &quot;Lea&quot;, &quot;Sarina&quot;, &quot;Remon&quot;, &quot;Letizia&quot;, &quot;Babice&quot;, &quot;Jonas&quot;, &quot;Wendy&quot;, &quot;Nivedithia&quot;, &quot;Gioia&quot;), Sexo= c(&quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;), Edad= c(30,25,25,29,22,22,35,19,32,21)) segunda&lt;- data.frame(Nombre= c(&quot;Astrid&quot;, &quot;Lea&quot;, &quot;Sarina&quot;, &quot;Remon&quot;, &quot;Letizia&quot;, &quot;Babice&quot;, &quot;Jonas&quot;, &quot;Wendy&quot;, &quot;Nivedithia&quot;, &quot;Gioia&quot;), Superhéroe= c(&quot;Batman&quot;, &quot;Superman&quot;, &quot;Batman&quot;, &quot;Spiderman&quot;, &quot;Batman&quot;, &quot;Antman&quot;, &quot;Batman&quot;, &quot;Superman&quot;, &quot;Maggot&quot;, &quot;Superman&quot;), Tatuajes= c(11,15,12,5,65,3,9,13,900,0)) knitr::kable(primera); knitr::kable(segunda) Nombre Sexo Edad Astrid F 30 Lea F 25 Sarina F 25 Remon M 29 Letizia F 22 Babice F 22 Jonas M 35 Wendy F 19 Nivedithia F 32 Gioia F 21 Nombre Superhéroe Tatuajes Astrid Batman 11 Lea Superman 15 Sarina Batman 12 Remon Spiderman 5 Letizia Batman 65 Babice Antman 3 Jonas Batman 9 Wendy Superman 13 Nivedithia Maggot 900 Gioia Superman 0 Para hacer: Combina las dos tablas en una sola y completa las siguientes asignaciones. ¿Cuál es la edad media de las mujeres y hombres por separado? ¿Cuál fue el número más alto de tatuajes en un hombre? ¿Cuál es el porcentaje de personas debajo de 32 años que son mujeres? Agrega una nueva columna a a la data llamada tatuajes.por.año que muestre cuántos tatuajes por año se ha hecho cada persona por cada año en su vida. ¿Cuál persona tiene el mayor número de tatuajes por año? ¿Cuáles son los nombres de las mujeres a las que su superheroe favorito es superman? ¿Cuál es la mediana del número de tatuajes de cad apersona que está por encima de los 20 años y que su personaje favorito es Batman? 2.2.14.1 Resolviendo Combina las dos tablas en una sola y completa las siguientes asignaciones. encuestas&lt;-primera %&gt;% full_join(segunda) ## Joining with `by = join_by(Nombre)` 2. ¿Cuál es la edad media de las mujeres y hombres por separado? encuestas %&gt;% group_by(Sexo) %&gt;% summarise_at(c(&quot;Edad&quot;), mean) ## # A tibble: 2 × 2 ## Sexo Edad ## &lt;chr&gt; &lt;dbl&gt; ## 1 F 24.5 ## 2 M 32 3. ¿Cuál fue el número más alto de tatuajes en un hombre? encuestas %&gt;% filter(Sexo==&quot;M&quot;) %&gt;% filter(Tatuajes == max(Tatuajes)) ## Nombre Sexo Edad Superhéroe Tatuajes ## 1 Jonas M 35 Batman 9 4. ¿Cuál es el porcentaje de mujeres debajo de 32 años? fem&lt;- encuestas %&gt;% filter(Sexo==&quot;F&quot;) fem_32&lt;- encuestas %&gt;% filter( Sexo==&quot;F&quot;, Edad&lt;32) (nrow(fem_32)/nrow(fem))*100 ## [1] 87.5 5. Agrega una nueva columna a a la data llamada tatuajes.por.año que muestre cuántos tatuajes por año se ha hecho cada persona por cada año en su vida. encuestas&lt;- encuestas %&gt;% mutate(&quot;tatuajesporaño&quot;=Tatuajes/Edad) encuestas$tatuajesporaño ## [1] 0.3666667 0.6000000 0.4800000 0.1724138 2.9545455 0.1363636 0.2571429 0.6842105 28.1250000 ## [10] 0.0000000 6. ¿Cuál persona tiene el mayor número de tatuajes por año? encuestas %&gt;% filter(tatuajesporaño == max(tatuajesporaño)) ## Nombre Sexo Edad Superhéroe Tatuajes tatuajesporaño ## 1 Nivedithia F 32 Maggot 900 28.125 7. ¿Cuáles son los nombres de las mujeres a las que su superheroe favorito es superman? encuestas %&gt;% filter(Sexo==&quot;F&quot;, Superhéroe==&quot;Superman&quot;) %&gt;% select(Nombre) ## Nombre ## 1 Lea ## 2 Wendy ## 3 Gioia 8. ¿Cuál es la mediana del número de tatuajes de cada persona que está por encima de los 20 años y que su personaje favorito es batman? encuestas %&gt;% filter(Edad&gt;20, Superhéroe ==&quot;Batman&quot;) %&gt;% summarise(mediana=median(Tatuajes)) ## mediana ## 1 11.5 https://bookdown.org/ndphillips/YaRrr/arranging-plots-with-parmfrow-and-layout.html↩︎ "],["gráficos-en-r.html", "Capítulo 3 Gráficos en R 3.1 Gráficas en R base 3.2 Gráficas con ggplot2() 3.3 Figuras Multi-panel / Facets 3.4 Extras", " Capítulo 3 Gráficos en R 3.1 Gráficas en R base R cuenta con un sistema de generación de gráficas poderoso y flexible. En este capítulo revisaremos como crear las gráficas más comunes con R base y luego un poco más complejas usando ggplot2 del tidyverse. 3.1.1 La función plot() La función plot() es usada de manera general para generar gráficos. Esta función es muy especial porque depende del tipo de datos que le demos generará diferentes tipos de gráficos. El argumento principal que pide esta función es “x” también podemos poner “y”. Y depende de estos el tipo de gráfica que se generará. Diremos: Continuo: Cuando nos referimos a un vector numérico, entero, lógico o complejo. Discreto: Cuando nos referimos a un vector de factores o cadenas de texto. x y Tipo Gráfico Continuo Continuo Dispersión /Scatter Continuo Discreto Dispersión y coercionada a numérica Continuo Ninguno Dispersión por número de renglón Discreto Continuo Boxplot/Cajas Discreto Discreto Mosaico Discreto Ninguno Barras #Ejemplos par(mfrow= c(2,3) ) plot(x=iris$Sepal.Length, y=iris$Sepal.Width) plot(x=iris$Sepal.Length, y = iris$Species) plot(x=iris$Sepal.Length) plot(x = iris$Species, y = iris$Sepal.Length) plot(x=iris$Species, y=iris$Species) plot(x=iris$Species) Además de estas, también hay otras funciones de Rbase que nos permiten graficar tipos específicos como son barplot(), boxplot() o hist(). 3.1.2 Histrogramas Los histogramas ya los vimos en el capítulo de estadísticos. Sabemos que nos permiten ver la distribución de nuestros datos (si son normales o no). Sin embargo, podemos usar más argmentos para darle formato, veamoslo con un ejemplo: hist(x = iris$Sepal.Length, main = &quot;Histograma de longitud de sepalo&quot;, xlab = &quot;Longitud&quot;, ylab = &quot;Frecuencia&quot;, col = &quot;purple&quot;) Como vemos en este ejemplo hay argumentos que aplicamos que puede ser aplicados para todos los gráficos de Rbase, tales como: main : Titulo de la gráfica xlab y ylab: Títulos de los axis x y y col : color de las barras o gráfica. 3.1.3 Diagramas de dispersión Estos diagramas nos son útiles para ver las relaciones que hay entre dos variables continuas. En el siguiente ejemplo veremos la relación entre las variables longitud y ancho del pétalo, pero en este caso los colorearemos por especies: plot(x = iris$Petal.Length, y = iris$Petal.Width, col = iris$Species, xlab = &quot;Largo&quot;, ylab = &quot;Ancho&quot;) Si queremos agregar una leyenda a alguna de nuestras figuras de Rbase, usamos la función legend(): legend() siempre nos pide siempre los siguientes argumentos. legend: Las etiquetas de los datos que queremos describir con la leyenda. Por ejemplo, si tenemos cuatro categorías a describir, proporcionamos un vector de cuatro cadenas de texto. fill: Los colores que acompañan a las etiquetas definidas con legend. Estos colores tienen que coincidir con los que hemos usado en el gráfico. x y y: Las coordenadas en pixeles, en las que estará ubicada la leyenda. Podemos dar como argumento a x alguno de los siguientes, para ubicar automáticamente la leyenda: “bottomright”, “bottom”, “bottomleft”, “left”, “topleft”, “top”, “topright”, “right”, “center”. title: Para poner título a la leyenda. Veámoslo con el mismo ejemplo, primero ponemos plot() con la gráfica que queremos y debajo legend() para ponerlo encima de la figura que ya habíamos hecho: plot(x = iris$Petal.Length, y = iris$Petal.Width, col = iris$Species, main = &quot;Pétalo Iris por especie&quot;, xlab = &quot;Largo&quot;, ylab = &quot;Ancho&quot;) legend(x = &quot;topleft&quot;, legend = c(&quot;Setosa&quot;, &quot;Versicolor&quot;, &quot;Virginica&quot;), fill = c(&quot;black&quot;, &quot;red&quot;, &quot;green&quot;), title = &quot;Especie&quot;) 3.1.4 Boxplots o diagramas de cajas Los diagramas de cajas o boxplots son gráficos que nos muestran la distribución de una variable mostrando sus cuartiles (parte baja primer cuartil y parte alta tercer cuartil), de manera que podamos ver su distribución y simetría. La línea horizontal media representa la “mediana” y las dos líneas verticales que muestran el valor máximo y mínimo. Veamos un ejemplo: plot(x=iris$Species, y = iris$Sepal.Length, xlab = &quot;Especie&quot;, ylab = &quot;Longitud Sépalo&quot;, col = c(&quot;purple&quot;, &quot;pink&quot;, &quot;blue&quot;)) También podemos usar la función boxplot(). En esta segunda forma de hacer diagramas de cajas necesitamos declarar dos argumentos principales: formula: Para esta función las fórmulas tienen el formato y ~ x, donde x es el nombre de la variable continua a graficar, y la x es la variable que usaremos como agrupación. data: Es el data frame del que serántomadas las variables. Además declarar los demás argumentos extras como colores, títulos y demás. boxplot(formula = Sepal.Length ~ Species, data = iris, xlab = &quot;Especie&quot;, ylab = &quot;Longitud Sépalo&quot;, col = c(&quot;purple&quot;, &quot;pink&quot;, &quot;blue&quot;)) 3.1.5 Otros gráficos Usando la función plot() podemos dibujar más gráficos de los vistos que son los estándares, como fue el caso cuando graficas modelos lineales. También existe otro argumento de esta función que se denomina type y nos permite escoger otros tipos de gráficos. Esto lo podemos ver usando el ‘?’ para ver la ayuda y los argumentos. ?plot Son posibles los siguientes valores: “p” para puntos, “l” para líneas, “b” para puntos y líneas, “c” para puntos vacíos unidos por líneas, “o” para puntos sobretrazados y líneas, “s” y “S” para escalones y “h” para líneas verticales similares a histogramas. Finalmente, “n” no produce ningún punto o línea. Veamos algunos ejemplos: #dataset de ensayo df&lt;- data.frame(x= c(1:5), y= c(200, 400, 600, 700, 500)) par(mfrow = c(2, 3)) plot(df$x, df$y, type = &quot;p&quot;, main = &#39;type = &quot;p&quot;&#39;) plot(df$x, df$y, type = &quot;l&quot;, main = &#39;type = &quot;l&quot;&#39;) plot(df$x, df$y, type = &quot;b&quot;, main = &#39;type = &quot;b&quot;&#39;) plot(df$x, df$y, type = &quot;c&quot;, main = &#39;type = &quot;c&quot;&#39;) plot(df$x, df$y, type = &quot;s&quot;, main = &#39;type = &quot;s&quot;&#39;) plot(df$x, df$y, type = &quot;h&quot;, main = &#39;type = &quot;h&quot;&#39;) Ahora bien, en cuanto a líneas podemos escoger el tipo de línea con el argumento lty: par(mfrow = c(2, 3)) plot(df$x, df$y, type = &quot;l&quot;, lty=1, main = &#39;type = &quot;l1&quot;&#39;) plot(df$x, df$y, type = &quot;l&quot;, lty=2, main = &#39;type = &quot;l2&quot;&#39;) plot(df$x, df$y, type = &quot;l&quot;, lty=3, main = &#39;type = &quot;l3&quot;&#39;) plot(df$x, df$y, type = &quot;l&quot;, lty=4, main = &#39;type = &quot;l4&quot;&#39;) plot(df$x, df$y, type = &quot;l&quot;, lty=5, main = &#39;type = &quot;l5&quot;&#39;) plot(df$x, df$y, type = &quot;l&quot;, lty=6, main = &#39;type = &quot;l6&quot;&#39;) 3.1.6 Barplots o gráficas de barras Las gráficas de barras nos permiten ver los valores de una manera diferente a las líneas: barplot(y ~ x , data = df, main = &quot;Barplot&quot;, col = &quot;darkred&quot;) También hay capas que podemos agregarle a las gráficas, como la capa text o la capa abline para agregar texto y líneas sobre la gráfica, por ejemplo: plot(df$x, df$y, type = &quot;p&quot;, main = &#39;type = &quot;p-capas&quot;&#39;) abline(h=400, v=3, col=&quot;red&quot;, lty=2) text(df, labels=rownames(df), cex=0.7, pos=2, col=&quot;blue&quot;) 3.1.7 Guardando una gráfica Para guardar o exportar una gráfica debemos: Indicar las instrucciones de cómo exportaremos la imagen Usar plot() y graficarla y luego, dev.off() para quitarla del panel y exportarla png(filename=&quot;gráfica1.png&quot;, width=648, height=432) plot(df$x, df$y, type = &quot;p&quot;, main = &#39;type = &quot;p&quot;&#39;) dev.off() 3.2 Gráficas con ggplot2() Las gráficas con ggplot2() es quizás de las cosas más poderosas y atractivas de R si lo comparamos con otros lenguajes y/o programas. ggplot2 es generalmente más intuitiva porque usa una gramática de gráficos además de ser visualmente agradable. La limitación de ggplot2 es que está diseñado para trabajar exclusivamente con tablas de datos en formato tidy (donde las filas son observaciones y las columnas son variables). Sin embargo,ya vimos en anteriores temas cómo podemos convertir nuestras tablas para que tengan este formato. Para usar ggplot2, tendrán que aprender varias funciones y argumentos. Estos son difíciles de memorizar, por lo que les recomendamos que tengan a mano la hoja de referencia de ggplot2. Pueden obtener una copia en línea o simplemente realizar una búsqueda en internet de “ggplot2 cheat sheet.” y econtraran algo como esto: O también en este link: cheaseet, donde podrán ver además estas hojas con indicaciones de otros paquetes de R que nos facilitarán un poco más las cosas. Es fácil de usar, pero puedes crear figuras complejas con una sintaxis bastante simple. “gg” significa gramática gráfica - Significa que se superponen diferentes capas de objetos y elementos sobre los anteriores para generar la figura. En esta parte se repasará las diferentes características de ggplot2: geomas o “geoms” escalas o “scales” guías o “guides” temas o “theme” facetas o “facets” El primer paso para aprender ggplot2 es poder separar un gráfico en componentes. Las figuras aquí, se construyen por capas. Los tres componentes principales para considerar son: Data: nuestro set de datos o dataframe Mapeo estético o ‘aes’: El gráfico usa varias señales visuales para representar la información proveída por el set de datos. Las dos señales más importantes en este gráfico son las posiciones de los puntos en el eje-x y el eje-y. Geometría: Nos indica el tipo de gráfica a realizar. Unas posibles geometrías son diagrama de barras, dispersión, histograma, densidades suaves (smooth densities en inglés), gráfico Q-Q y diagrama de cajas. Elementos adicionales: temas, guías, colores, etc. Para esta parte usaremos como ejemplo el set de Datos de “ToothGrotwth” de nuevo y contruiremos por partes la gráfica. 3.2.1 ggplot El primer paso para crear un gráfico ggplot2 es definir un objeto ggplot. Hacemos esto con la función ggplot, que inicializa el gráfico. Esta parte podemos hacerla evaluando dentro de la función o usando el pipe, así: data(&quot;ToothGrowth&quot;) library(dplyr) library(ggplot2) ggplot(data = ToothGrowth) ToothGrowth %&gt;% ggplot() El código crea un gráfico, en este caso una pizarra en blanco ya que no se ha definido la geometría. La única opción de estilo que vemos es un fondo gris. También dentro de esta capa de ggplot() se declara algo que se conoce como mapeo estético que describe cómo las propiedades de los datos se conectan con las características del gráfico. En otras palabras, más coloquiales, qué con qué graficamos, también podemos colocar aquí si queremos colorear o llenar un factor. Por ejemplo, con la data de ToothGrowth, queremos graficar el tamaño o longitud de los dientes versus la dosis aplicada y destacando o coloreando el método de aplicación de la vitamina C. ToothGrowth %&gt;% ggplot(aes(x = dose, y = len, fill=supp)) Aquí ya vemos que el eje x y el eje y ya aparecen con nombres de las variables, pero aún no nos muestra ningún gráfico, esto es porque no le indicamos aún que geometría o qué tipo de gráfico queremos. 3.2.2 Geometrías Esta es la siguiente capa en ggplot2. Los nombres de las funciones de geometría siguen el patrón: geom_$ donde $ es el nombre de la geometría. Algunos ejemplos incluyen geom_bar, geom_point y geom_histogram. Digamos que queremos ahora sí dibujar la gráfica del paso anterior pero usando puntos, para esto usamos la geometría geom_point . Luego de cada capa de ggplot2 en vez de usar pipe usamos el signo + y así vamos agregando cada capa. ToothGrowth %&gt;% ggplot(aes(x = dose, y = len, color=supp)) + geom_point() Ahora sí podemos ver lo que queríamos, cómo lucen los datos de longitud en cada dosis aplicada destacando o coloreando el modo de administración. Si en vez de puntos quisieramos, líneas, pues sólo cambiamos la capa de geometría: ToothGrowth %&gt;% ggplot(aes(x = dose, y = len, color=supp)) + geom_line() También podemos combinar lo visto en tidyverse con ggplot2 por ejemplo si queremos hacer un boxplot o barplot debemos cambiar la variable de dosis para hacerla discreta en vez de numérica o continua. ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, color=supp)) + geom_boxplot() En el caso de geom_bar debemos cambiar y poner más argumentos, por ejemplo, como las barras son huecas en vez de usar ‘color’ usamos ‘fill’ y dentro de la geomtría escogemos una stat y una position , esto es para indicar cómo estarán las barras ubicadas y representadas. Los argumentos más usados para barras tradicionales los presento a continuación: ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes( x = dose, y = len, fill=supp)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) Podemos también agregar más de una capa de geometría y así hacer gráficas combinadas, por ejemplo: ToothGrowth %&gt;% ggplot(aes(x = dose, y = len, color=supp)) + geom_point()+ geom_text(aes(label=rownames(ToothGrowth)))+ geom_line() En la gráfica pasada combinamos tres geometrías, puntos, texto y línea. De esta forma podemos hacer gráficas más elaboradas y mejor representadas. 3.2.3 Colores, títulos, escalas y otros ajustes. Hasta ahora hemos construido gráficas con ggplot2() declarando el mapa estético y las diferentes geometrías. Sin embargo podemos notar de todas nuestras figuras anteriores que lucen muy parecidas en formato, mismos colores, mismo fondo y demás. Todos estos parámetros podemos modificarlos para personalizar nuestras figuras. 3.2.3.1 Colores ggplot2() tiene su escala personalizadas de colores, como lo vimos anteriormente. Sin embargo esto podemos cambiarlo usando una capa denominada scale_color_$, tomando $ varias formas, como scale_color_manual(), scale_color_continuous(),scale_color_discrete(), scale_color_brewer() , entre otros. Todas estas opciones son depende de nuestro tipo de datos o del tipo de escala que queremos utilizar. Para declarar los colores en R podemos utilizar los nombres de los colores inglés como lo hicimos en la parte de R base o usando el formato de colores de html. También hay muchas paletas de varios paquetes ya definidas como la de RColorBrewer y viridis. Para buscar los colores en formato html pomos usar el siguiente link: html-colors. El código html se ve de esta manera: Y de esta manera los declaramos en nuestra gráfica usando scale_color_manual(): ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, col=supp)) + geom_boxplot()+ scale_color_manual(values = c(&quot;#FF00FF&quot;,&quot;#00FFFF&quot;)) Ahora bien, como les mencioné anteriormente los diagramas de cajas y barras son elementos huecos entonces cuando indicados col lo que realmente coloreamos son los bordes, pero si queremos colorear las cajas adentro debemos usar fill como usamos en el geom_bar(), pero, en este caso en vez de usar scale_color_$, usamos scale_fill_$ y de esta manera podemos reemplazarlo por todas las opciones anteriormente mencionadas: ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ scale_fill_manual(values = c(&quot;#FF00FF&quot;,&quot;#00FFFF&quot;)) Ahora, si dudamos mucho o no estamos seguros de cómo escoger los colores, podemos utilizar paletas de colores ya determinadas como las que mencioné RColorBrewer y viridis. Estas son las paletas de RColorBrewer y viridis: Y así las podemos usar: ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ scale_fill_brewer(palette = &quot;Dark2&quot;) ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ scale_fill_viridis_d(option = &quot;C&quot;) Entonces para brewer ponemos el nombre de la paleta que queremos uscar y el viridis ponemos la opción de paleta que queremos: “magma” (o “A”), “inferno” (“B”), “plasma” (“C”), “viridis” (“D”, default) and “cividis” (o “E”). 3.2.3.2 Títulos Para asignar los títulos al eje x y al eje y podemos usar las capas xlab() y ylab(). Y para el título principal usamos ggtitle() . Así: ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ ylab(&quot;Longitud diente&quot;)+ xlab(&quot;Dosis&quot;)+ ggtitle(&quot;Longitud de dientes por Dosis aplicada&quot;) 3.2.4 Escalas Para establecer o cambiar las escalas de nuestra figura usamos las funciones scale_x_discrete() o scale_y_continuos()dependiendo del tipo de datos que tengamos (cotinuos o numéricos y discretos o categóricos) en cada axis (x o y) y. ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ ylab(&quot;Longitud diente&quot;)+ xlab(&quot;Dosis&quot;)+ ggtitle(&quot;Longitud de dientes por Dosis aplicada&quot;) + scale_x_discrete(limits = c(&quot;D2&quot;, &quot;D0.5&quot;, &quot;D1&quot;), position =&quot;bottom&quot; )+ scale_y_continuous(breaks = c(0, 20,40), limits = c(0,40), labels = c(&quot;L0&quot;, &quot;L20&quot;, &quot;L40&quot;)) Como vemos, podemos explorar y probar diferentes parámetros para cambiar en el eje x y en el eje y sin tener que modificar nuestros datos sino solamente para ser graficado. 3.2.5 Otros ajustes Hay otros ajustes más geneales o específicos que podemos realizar a nuestros gráficos. Por ejemplo, los temas. ggplot2() usa como default el tema theme_grey() pero hay otros que podemos usar para cambiar el formarto de nuestras figuras. Veamos algunos ejemplos: Y así muchos otros más, los podemos explorar dando theme_ y usando la tecla TAB para ver las demás opciones que nos aparecen. Otros ajustes más específicos como tamaño y color de letras, posición de la leyenda, entre otros, los hacemos usando la capa denominada theme(). Vamos a dar un ejemplo de cómo hacer esto, pero para usar thene() es todo un capítulo muy extenso para entrar en detalles, si queremos conocer muchos de estos detalles hacemos ?theme() y nos depliega la página de ayuda y veremos los argumentos posibles. ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ theme(axis.title = element_text(size = &quot;14&quot;, colour = &quot;blue&quot;), title = element_text(size = 16, colour = &quot;red&quot;), legend.position = &quot;top&quot;) 3.3 Figuras Multi-panel / Facets Para dibujar varias figuras en una misma página o output hay varias estrategias. Varias de ellas están fuera del alcance de este curso, pero para mencionarlas: par (multi-panel con R base)10 cowplot (ggplot2)11 grid.arrange(ggplot2)12 Facets 3.3.1 Facets Esta forma de graficar en multi-panel es quizás la más sencilla por ser una capa de ggplot2(). Para esta hay dos funciones facet_grid()y facet_wrap(). Los trataremos como ejemplos porque en detalle no son del alcance del presente curso. Para facet_grid() hay dos opciones, presentarla por columnas o por filas: ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ facet_grid(supp~.) ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ facet_grid(.~supp) Y con facet_wrap() podemos combinar columnas y filas, por ejemplo: ToothGrowth %&gt;% mutate(dose=case_when( dose==0.5~&quot;D0.5&quot;,dose==1~&quot;D1&quot;, dose==2~&quot;D2&quot;)) %&gt;% ggplot( aes(x = dose, y = len, fill=supp)) + geom_boxplot()+ facet_wrap(~supp+dose, ncol = 3, nrow = 2) 3.3.1.1 Guardando una gráfica en ggplot2 Para guardar una gráfica de tipo ggplot2() usamos la función ggsave() ggsave(filename = &quot;plot.png&quot;, plot = a1, dpi = 300,width = 4, height = 3.5) 3.4 Extras 3.4.1 stat_summary() y stat_smoot() Esta es una capa que nos permite poner desviaciones estándar o líneas que representan el promedio de los datos, por ejemplo: ToothGrowth %&gt;% ggplot(aes(x = dose, y = len)) + stat_summary(geom = &quot;line&quot;, fun = mean, aes(group = supp, color = supp), size = 1.2) + stat_summary(geom = &quot;errorbar&quot;, fun.data = mean_se, aes(group = supp), width = 0.1) stat_smooth() nos permite colorear o resaltar la línea que representa nuestro modelo lineal: ggplot(iris, aes(x = Petal.Width, y = Sepal.Length)) + geom_point() + stat_smooth(method = &quot;lm&quot;, col = &quot;red&quot;) ## `geom_smooth()` using formula = &#39;y ~ x&#39; 3.4.2 ggpubr() ggpubr() es una paqutería tipo compatible con ggplot2() pero un poco más fácil de declarar y más intuitivo. Veamos algunos pocos ejemplos de sus utilidades: library(ggpubr) ggboxplot(ToothGrowth, x = &quot;dose&quot;, y = &quot;len&quot;, color = &quot;dose&quot;,add = &quot;jitter&quot;, shape = &quot;dose&quot;) ggbarplot(ToothGrowth, x = &quot;dose&quot;, y = &quot;len&quot;, fill = &quot;dose&quot;, add = &quot;mean_se&quot;) Vemos que los parámetros se definen similarmente pero con algunas diferencias, además que nos permite agregarles más elementos sin agregar más capas. Y el ‘output’ o tipo de gráfica es igual del tipo ggplot2(). Otras funciones interesantes de este paquete son facet.by que es un argumento que puede ser declarado dentro de la función principal y nos permite hacer las gráficas multi-panel y otro que es muy útil es el de stat_compare_means() que nos permite agregar una capa que hace análisis estátidísticos como t.test, wilcoxon, kruskal.walis, anova, entre otros y que nos evita hacer análisis fuera y que podamos agragarlas a la gráfica en un sólo paso. ggboxplot(ToothGrowth, x = &quot;dose&quot;, y = &quot;len&quot;, color = &quot;dose&quot;,facet.by = &quot;supp&quot;) comparaciones &lt;- list( c(&quot;0.5&quot;, &quot;1&quot;), c(&quot;1&quot;, &quot;2&quot;), c(&quot;0.5&quot;, &quot;2&quot;) ) ggbarplot(ToothGrowth, x = &quot;dose&quot;, y = &quot;len&quot;, fill = &quot;dose&quot;, add = &quot;mean_sd&quot;)+ stat_compare_means(comparisons = comparaciones, label = &quot;p.signif&quot;) 3.4.3 Misceláneos: ggcats()13 ggplot2() nos permite usar diversos paquetes desarrollados por muchos usarios con fines divertidos o misceláneos, podemos verlo en el pie de página el link para explorar todos los que hay. Veremos ggcats(). Estas son las opciones que podemos usar: # install.packages(&quot;magick&quot;) # remotes::install_github(&quot;R-CoderDotCom/ggcats@main&quot;) library(ggcats) grid &lt;- expand.grid(1:5, 3:1) df &lt;- data.frame(x = grid[, 1], y = grid[, 2], image = c(&quot;nyancat&quot;, &quot;bongo&quot;, &quot;colonel&quot;, &quot;grumpy&quot;, &quot;hipster&quot;, &quot;lil_bub&quot;, &quot;maru&quot;, &quot;mouth&quot;, &quot;pop&quot;, &quot;pop_close&quot;, &quot;pusheen&quot;, &quot;pusheen_pc&quot;, &quot;toast&quot;, &quot;venus&quot;, &quot;shironeko&quot;)) ggplot(df) + geom_cat(aes(x, y, cat = image), size = 5) + geom_text(aes(x, y - 0.5, label = image), size = 2.5) + xlim(c(0.25, 5.5)) + ylim(c(0.25, 3.5)) Entonces, por ejemplo si queremos usarlos como puntos de nuestra gráfica, sería algo así: #hacemos la variable cats para escoger los que queremos ToothGrowth$cats &lt;- factor(ToothGrowth$dose, levels = c(0.5,1,2), labels = c(&quot;mouth&quot;, &quot;grumpy&quot;, &quot;pusheen_pc&quot;)) ToothGrowth %&gt;% ggplot(aes(y = len, x = dose)) + geom_cat(aes(cat = cats), size = 4) + xlim(c(0.25, 2.25)) 3.4.4 Misceláneos: ggtexttable() Esta función me permite hacer mis tablas como figuras que puedo exportar como imágenes y darle formato. Hace parte del paquete ggpubr() que vimos anteriormente. Haremos un ejemplo con los primeros cuatro datos de iris: library(dplyr) df&lt;- iris %&gt;% slice(c(1:4)) ggtexttable(df, rows = NULL) También podemos cambiar el tema con el que se formatea la tabla, por ejemplo: ggtexttable(df, rows = NULL, theme = ttheme(&quot;blank&quot;)) ggtexttable(df, rows = NULL, theme = ttheme(&quot;light&quot;)) ggtexttable(df, rows = NULL, theme = ttheme(&quot;classic&quot;)) ggtexttable(df, rows = NULL, theme = ttheme(&quot;minimal&quot;)) ggtexttable(df, rows = NULL, theme = ttheme(&quot;lVioletWhite&quot;)) ggtexttable(df, rows = NULL, theme = ttheme(&quot;mVioletWhite&quot;)) Para ver otros temas: https://rpkgs.datanovia.com/ggpubr/files/ggtexttable-theme.pdf Otros formateos: Poner en negrita una celda: ggtexttable(df, rows = NULL, theme = ttheme(&quot;classic&quot;)) %&gt;% table_cell_font(row = 3, column = 2, face = &quot;bold&quot;, color = &quot;red&quot;) Resaltar una columna: ggtexttable(df, rows = NULL, theme = ttheme(&quot;classic&quot;)) %&gt;% table_cell_bg(row = 2:5, column = 3, fill=&quot;yellow&quot;) Poner títulos y pies de notas: ggtexttable(df, rows = NULL, theme = ttheme(&quot;classic&quot;)) %&gt;% tab_add_title(text = &quot;Data iris&quot;, size = 14, face=&quot;bold&quot;) %&gt;% tab_add_footnote(text = &quot;*Alguna nota&quot;, size = 10, face = &quot;italic&quot;) https://bookdown.org/ndphillips/YaRrr/arranging-plots-with-parmfrow-and-layout.html↩︎ https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html↩︎ https://cran.r-project.org/web/packages/egg/vignettes/Ecosystem.html↩︎ https://r-charts.com/es/miscelanea/↩︎ "],["valor-de-significancia-p-en-estadística-p-value.html", "Capítulo 4 Valor de significancia p en estadística (p-value) 4.1 ¿Qué es el valor p? 4.2 Interpretación general del valor p 4.3 Marco de prueba de hipótesis: relación con la hipótesis nula y alternativa 4.4 Regla de decisión: umbrales comunes para el valor p 4.5 Errores en la prueba de hipótesis: error tipo I (falso positivo) y error tipo II (falso", " Capítulo 4 Valor de significancia p en estadística (p-value) 4.1 ¿Qué es el valor p? 4.2 Interpretación general del valor p 4.3 Marco de prueba de hipótesis: relación con la hipótesis nula y alternativa 4.4 Regla de decisión: umbrales comunes para el valor p 4.5 Errores en la prueba de hipótesis: error tipo I (falso positivo) y error tipo II (falso "],["introducción-a-la-estadística.html", "Capítulo 5 Introducción a la estadística 5.1 Diferencia entre estadística y bioestadística 5.2 Estadística descriptiva: medidas de tendencia central y medidas de dispersión 5.3 Estadística inferencial: Univariada y multivariada 5.4 Estadística inferencial paramétrica: supuestos principales de las pruebas paramétricas 5.5 Estadística inferencial no paramétrica: supuestos principales de las pruebas no paramétricas 5.6 ¿Cómo saber si mis datos presentan una distribución normal y homogeneidad de las variancias?: 5.7 Estadísticos descriptivos 5.8 Gráficos descriptivos 5.9 Explorando normalidad en los datos 5.10 Correlación y Regresión 5.11 ANOVA (1 vía) 5.12 Prueba de Tukey 5.13 ANOVA (2 vías)", " Capítulo 5 Introducción a la estadística 5.1 Diferencia entre estadística y bioestadística 5.2 Estadística descriptiva: medidas de tendencia central y medidas de dispersión 5.3 Estadística inferencial: Univariada y multivariada 5.4 Estadística inferencial paramétrica: supuestos principales de las pruebas paramétricas 5.5 Estadística inferencial no paramétrica: supuestos principales de las pruebas no paramétricas 5.6 ¿Cómo saber si mis datos presentan una distribución normal y homogeneidad de las variancias?: 5.6.1 Prueba de Shapiro-Wilk 5.6.2 Pruebas de ajuste o distribución: Prueba de Kolmogorov-Smirnov, Prueba de Anderson-Darling 5.6.3 Prueba de Leven (varianzas). Data Para la revisión de los estadísticos básicos en R trabajaremos con el dataset iris. data(iris) cols&lt;- c(&quot;Largo_Sepalo&quot;, &quot;Ancho_Sepalo&quot;, &quot;Largo_Petalo&quot;, &quot;Ancho_Petalo&quot;, &quot;Especies&quot;) colnames(iris)&lt;- cols Este conjunto de datos describe tres especies de las flores iris y como cambia el ancho y largo de su pétalo y sépalo. Veamos la estructura de los datos: str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Largo_Sepalo: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Ancho_Sepalo: num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Largo_Petalo: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Ancho_Petalo: num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Especies : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... dim(iris) ## [1] 150 5 nrow(iris) ## [1] 150 ncol(iris) ## [1] 5 Como vemos, posee 4 variables de respuesta y un factor que sería la especie de flor. 5.7 Estadísticos descriptivos Utilizando la función summary() podemos obtener información sobre nuestra data, como el valor mínimo, máximo, el promedio, la mediana y el rango intercuantil. summary(iris) ## Largo_Sepalo Ancho_Sepalo Largo_Petalo Ancho_Petalo Especies ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 setosa :50 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 versicolor:50 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 virginica :50 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 Si queremos estos datos por aparte o solo nos interesa estos y otros datos de la variable “Largo_Sepalo”, entonces usamos las funciones establecidas en R: mean(iris$Largo_Sepalo) ## [1] 5.843333 min(iris$Largo_Sepalo) ## [1] 4.3 max(iris$Largo_Sepalo) ## [1] 7.9 median(iris$Largo_Sepalo) ## [1] 5.8 quantile(iris$Largo_Sepalo, 0.25) # primer cuantil ## 25% ## 5.1 quantile(iris$Largo_Sepalo, 0.75) # tercer cuantil ## 75% ## 6.4 Otros estadísticos descriptivos… sd(iris$Largo_Sepalo) #desviación estándar ## [1] 0.8280661 range(iris$Largo_Sepalo) #min y max ## [1] 4.3 7.9 IQR(iris$Largo_Sepalo) #diferencia entre el tercer y primer cuantil ## [1] 1.3 var(iris$Largo_Sepalo) #varianza ## [1] 0.6856935 sd(iris$Largo_Sepalo) / mean(iris$Largo_Sepalo) #Coeficiente variación ## [1] 0.1417113 Para conocer la desviación estándar de todas las columnas numéricas, usamos la función apply como anteriormente vimos: lapply(iris[, 1:4], sd) ## $Largo_Sepalo ## [1] 0.8280661 ## ## $Ancho_Sepalo ## [1] 0.4358663 ## ## $Largo_Petalo ## [1] 1.765298 ## ## $Ancho_Petalo ## [1] 0.7622377 5.8 Gráficos descriptivos Si queremos explorar cómo es la variación de la longitud del sepalo por cada especie: boxplot(iris$Largo_Sepalo ~ iris$Especies) library(ggpubr) ggbarplot(data = iris, x = &quot;Especies&quot;, y = &quot;Largo_Sepalo&quot;, add = &quot;mean_sd&quot;) 5.9 Explorando normalidad en los datos Existen diversas gráficas que podemos realizar para probar o explorar si nuestros datos siguen una distribución normal (también llamada distribución gaussiana) y su gráfica debe tener una forma acampanada y simétrica. La aplicación de muchas pruebas y estadísticos depende de si los datos siguen esta distribución o no. Por esto es importante antes de aplicar cualquier prueba estadística, explorar la distribución de nuestros datos y sí la prueba o estadístico que aplicamos asume que nuestros datos sean normales o no. Para este ejemplo, usaremos el ancho del sepalo en vez del largo del sepalo. ¨ hist(iris$Ancho_Sepalo) plot(density(iris$Ancho_Sepalo)) qqnorm(iris$Ancho_Sepalo) qqline(iris$Ancho_Sepalo) library(car) # cargamos el paquete car qqPlot(iris$Ancho_Sepalo ) ## [1] 16 34 Al parecer nuestros datos tienen una distribución normal, según los gráficos, sin embargo, para estar seguros de esto, haremos una prueba llamada test de shapiro que nos permitirá confirmar esto: shapiro.test(iris$Ancho_Sepalo) ## ## Shapiro-Wilk normality test ## ## data: iris$Ancho_Sepalo ## W = 0.98492, p-value = 0.1012 La hipótesis nula que estamos aceptando o rechazando con esta prueba es que la distribución es normal y escogiendo un valor de probabilidad de 0.05 y dado que 0.1012 &gt; 0.05 no podemos rechazar la hipótesis nula. En caso que este valor de p-value &lt; 0.05 entonces los datos no serían normales. 5.10 Correlación y Regresión Correlación: Describe cómo dos variables están relacionadas. Es una herramienta común para describir relaciones simples sin hacer afirmaciones sobre causa y efecto. Estas relaciones pueden ser o no lineales, pero usualmente se busca o se desea saber si esta relación es lineal. Por ejemplo queremos saber si existe una relación entre el largo y el ancho del pétalo de estas flores sin importar la especie: cor.test(iris$Largo_Petalo, iris$Ancho_Petalo) ## ## Pearson&#39;s product-moment correlation ## ## data: iris$Largo_Petalo and iris$Ancho_Petalo ## t = 43.387, df = 148, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.9490525 0.9729853 ## sample estimates: ## cor ## 0.9628654 Los valores que más nos interesan aquí son el cor y el p-value: Para un valor de cor de +1 quiere decir que dos variables están perfectamente correlacionadas positivamente. Es decir, al aumentar una, aumenta la otra. Un valor de -1 significa que las dos variables están perfectamente relacionadas negativamente, es decir, mientras una aumenta, la otra disminuye en la misma medida. Un valor 0 significa que no hay correlación en las dos variables. El valor p es la probabilidad de obentener un valor de cor más que extremo que el cor observado, dado los grados de libertad y si cor fuera 0. Igualmente valores menores a 0.05 son significativos. Hay otra función que nos permite obtener solo el coeficiente de correlación, de manera más práctica: cor(iris$Largo_Petalo, iris$Ancho_Petalo) # si los datos son normales ## [1] 0.9628654 cor(iris$Largo_Petalo, iris$Ancho_Petalo, method = &quot;spearman&quot;) #si los datos no son normales ## [1] 0.9376668 Ahora bien, ya sabemos que estas dos variables están correlacionadas positivamente, así que si quiero construir un modelo que permite predecir valores en base a otros no medidos podemos aplicar una regresión lineal. Una regresión lineal es un modelo lineal que describe la ecuación de dos variables de interés definidas en una función lineal: y = ax + b, donde a es la pendiente y b el intercepto. La regresión lineal debe aplicarse sobre datos normales. Así que chequemos la normalidad. Primero, construimos el modelo y luego graficamos. El modelo se construye con la variable de respuesta al lado izquiero de la ecuación y la variable que la explique a la derecha divididos por un signo de “~” . modelo &lt;- lm(Ancho_Petalo ~ Largo_Petalo, data = iris) plot(modelo, which = 2) Son solo pocos puntos que se salen de la gráfica, así que asumimos normalidad. Exploremos el modelo: summary(modelo) ## ## Call: ## lm(formula = Ancho_Petalo ~ Largo_Petalo, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.56515 -0.12358 -0.01898 0.13288 0.64272 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.363076 0.039762 -9.131 4.7e-16 *** ## Largo_Petalo 0.415755 0.009582 43.387 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2065 on 148 degrees of freedom ## Multiple R-squared: 0.9271, Adjusted R-squared: 0.9266 ## F-statistic: 1882 on 1 and 148 DF, p-value: &lt; 2.2e-16 Con summary() podemos ver los coeficientes de la ecuación, en este caso son: para el intercepto -0.36 y para la pendiente es 0.41. De nuevo los valores p están por debajo de 0.05. Los coeficientes son la pendiente y el intercepto. Así que la ecuación queda -&gt; Ancho_Petalo = Largo_Petalo*0.4157 - 0.3630 Otro resultado importante es el R cuadrado que nos dice la bondad del ajuste del modelo, esto es la fracción de mis datos que es explicado por el modelo en este caso si miramos el valor ajustado, el modelo explica el 92% de mis datos. 5.11 ANOVA (1 vía) ANOVA o análisis de varianza es un método estadístico que nos permite comparar las varianzas entre las medias (promedios) de diferentes grupos. El ANOVA tiene varios supuestos: 1. Independencia: cada observación es independiente de otra. (Por ejemplo, si tenemos mediciones del mismo individuo a lo largo del tiempo, esta medida es dependiente al individuo). 2. Normalidad : Que los datos siguen una distribución normal (como verificamos anteriormente). 3. Homocedasticidad: varianzas equivalentes entre grupos. Para la condición 1, en ningún lado nos dice que son muestras longitudinales, es decir, del mismo individuo a lo largo del tiempo, así que asumimos independencia. Vamos a ver con estas dos gráficas si efectivamente se cumplen las condiciones 2 y 3. modelo_ancho &lt;- lm(Ancho_Sepalo ~ Especies, data = iris) plot(modelo_ancho, which = c(1,2) ) Este gráfico muestra si los residuos tienen patrones no lineales. Si encuentra residuos igualmente distribuidos alrededor de una línea horizontal sin patrones distintos, es una buena indicación de que no tiene relaciones no lineales. La linea roja debe ser más o menos recta, no debe estar curvada, entre más recta mejor. anova(modelo_ancho) ## Analysis of Variance Table ## ## Response: Ancho_Sepalo ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Especies 2 11.345 5.6725 49.16 &lt; 2.2e-16 *** ## Residuals 147 16.962 0.1154 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 En un sentido aplicado el número que más nos interesa es el valor F, sin embargo, se ha extendido la importancia del valor p que se define como la probabilidad de encontrar valores F más extremos que el observado y en este sentido la probabilidad es muy baja, mucho menor que el valor establecido como umbral que suele ser 0.05. Así que rechazamos la hipótesis nula, lo que quiere decir que las medias de las especies son diferentes para el ancho del sépalo. 5.12 Prueba de Tukey ANOVA nos dice que hay diferencias en el ancho del sepalo por especie, pero no nos dice cual es más grande o cuales menor, o cual es diferente a cual. Para esto hacemos una prueba de Tukey. La función aov() realiza lo mismo que la de anova(). fm1&lt;- aov(modelo_ancho) TukeyHSD(fm1, &quot;Especies&quot;, ordered = TRUE) ## Tukey multiple comparisons of means ## 95% family-wise confidence level ## factor levels have been ordered ## ## Fit: aov(formula = modelo_ancho) ## ## $Especies ## diff lwr upr p adj ## virginica-versicolor 0.204 0.04314472 0.3648553 0.0087802 ## setosa-versicolor 0.658 0.49714472 0.8188553 0.0000000 ## setosa-virginica 0.454 0.29314472 0.6148553 0.0000000 library(agricolae) HSD.test(fm1, &quot;Especies&quot;, group = TRUE, console = TRUE) ## ## Study: fm1 ~ &quot;Especies&quot; ## ## HSD Test for Ancho_Sepalo ## ## Mean Square Error: 0.1153878 ## ## Especies, means ## ## Ancho_Sepalo std r se Min Max Q25 Q50 Q75 ## setosa 3.428 0.3790644 50 0.0480391 2.3 4.4 3.200 3.4 3.675 ## versicolor 2.770 0.3137983 50 0.0480391 2.0 3.4 2.525 2.8 3.000 ## virginica 2.974 0.3224966 50 0.0480391 2.2 3.8 2.800 3.0 3.175 ## ## Alpha: 0.05 ; DF Error: 147 ## Critical Value of Studentized Range: 3.348424 ## ## Minimun Significant Difference: 0.1608553 ## ## Treatments with the same letter are not significantly different. ## ## Ancho_Sepalo groups ## setosa 3.428 a ## virginica 2.974 b ## versicolor 2.770 c Esta función aparte de ver las diferencias de medias nos ordena con letras cual es la mayor y cual es la menor, veamoslo mejor en una gráfica de barras. 5.13 ANOVA (2 vías) El análisis de varianza de dos vías nos ayuda a estudiar la relación entre una variable dependiente cuantitativa y dos variables independientes cualitativas (factores) cada uno con varios niveles. Este método hace todas las asunciones o supuestos que el ANOVA de 1 vía sobre normalidad y demás. También es importante recalcar que para este tipo los grupos deben tener el mismo número de muestras o réplicas. El ANOVA de dos vías permite estudiar cómo influyen por si solos cada uno de los factores sobre la variable dependiente (modelo aditivo) así como la influencia de las combinaciones que se pueden dar entre ellas (modelo con interacción). Modelo aditivo: aov(variable_respuesta ~ factor1 + factor2, data) Modelo con interacción: aov(variable_respuesta ~ factor1 x factor2, data) Para este ejemplo usaremos el set de datos ‘ToothGrowth’ con el que trabajamos la clase pasada. data(&quot;ToothGrowth&quot;) str(ToothGrowth) ## &#39;data.frame&#39;: 60 obs. of 3 variables: ## $ len : num 4.2 11.5 7.3 5.8 6.4 10 11.2 11.2 5.2 7 ... ## $ supp: Factor w/ 2 levels &quot;OJ&quot;,&quot;VC&quot;: 2 2 2 2 2 2 2 2 2 2 ... ## $ dose: num 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 ... Como podemos observar la variable de respuesta aquí sería la longitud de los dientes y los factores a evaluar son ‘supp’ y ‘dose’, supp es la forma en que le dieron la vitamia C a los cerdos, si como OJ (jugo de naranja) o AS (ácido ascórbico) a diferentes dosis (dose) de 0.5, 1 y 2 mg/día. El factor ‘dose’ o dosis no aparece como factor sino como variable numérica. Esto puede ser un inconveniente al correr el ANOVA así que modificaremos esto en la data. ToothGrowth$dose &lt;- factor(ToothGrowth$dose, levels = c(0.5, 1, 2), labels = c(&quot;D0.5&quot;, &quot;D1&quot;, &quot;D2&quot;)) head(ToothGrowth) ## len supp dose ## 1 4.2 VC D0.5 ## 2 11.5 VC D0.5 ## 3 7.3 VC D0.5 ## 4 5.8 VC D0.5 ## 5 6.4 VC D0.5 ## 6 10.0 VC D0.5 Bien, visualizaremos nuestros datos para ver las tendencias de nuestros factores sobre nuestra variable de respuesta: Boxplots : library(ggpubr) ggboxplot(data = ToothGrowth, x = &quot;supp&quot;, y = &quot;len&quot;, fill = &quot;supp&quot;) ggboxplot(data = ToothGrowth, x = &quot;dose&quot;, y = &quot;len&quot;, fill = &quot;dose&quot;) ggboxplot(data = ToothGrowth, x = &quot;dose&quot;, y = &quot;len&quot;, fill = &quot;supp&quot;) Líneas: ggline(ToothGrowth, x = &quot;dose&quot;, y = &quot;len&quot;, color = &quot;supp&quot;, add = c(&quot;mean_se&quot;, &quot;jitter&quot;)) Como pudimos ver aparentemente los factores podrían tener una interacción aunque muy level, en este caso podríamos correr una ANOVA dos vías o bien aditivo o bien mutiplicativo si queremos confirmar esta pequeña interacción. anova1&lt;- aov(len ~ supp + dose, data = ToothGrowth) anova2&lt;- aov(len ~ supp * dose, data = ToothGrowth) summary(anova1) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## supp 1 205.4 205.4 14.02 0.000429 *** ## dose 2 2426.4 1213.2 82.81 &lt; 2e-16 *** ## Residuals 56 820.4 14.7 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 summary(anova2) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## supp 1 205.4 205.4 15.572 0.000231 *** ## dose 2 2426.4 1213.2 92.000 &lt; 2e-16 *** ## supp:dose 2 108.3 54.2 4.107 0.021860 * ## Residuals 54 712.1 13.2 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Como notamos tanto el modelo aditivo como multiplicativo, los factores explican de buena manera la varianza de nuestra variable. Sin embargo en el modelo multiplicativo, que es el que nos muestra la interacción, nos dice que efectivamente hay una interacción entre nuestros factores (aunque muy pequeña), es decir, que el efecto de un factor depende del otro factor. Las pruebas que realizamos anteriormente son de las comunes aplicadas para los conjuntos de datos, pero hay otras que podemos realizar también, por ejemplo en el caso de datos normales para hacer pruebas pareadas (dos niveles) podemos utilizar tambien t.testo en caso de no ser normales wilcoxon.test, en el caso de mas niveles para no parametricas podemos usar kruskal.test. Por ejemplo: #dos niveles t.test(len ~ supp, data = ToothGrowth, paired = TRUE) wilcox.test(len ~ supp, data = ToothGrowth, paired = TRUE) #más de dos niveles kruskal.test(len ~ dose, data = ToothGrowth) Hay otras pruebas que se aplican dependiendo de los datos que tengamos y el objetivo de nuesto pregunta de investigación por ejemplo Dunn.test, Duncan.test, Welch.test, entre otros. Hay muchos paquetes además de los que trae por default R stats (que viene por default con R) tales como agricolae, vegan, emmeans , entre otros, que vienen con más funciones y pruebas aplicadas a datos biológicos, ecológicos, entre otros. "],["tipos-de-pruebas-paramétricas.html", "Capítulo 6 Tipos de pruebas paramétricas 6.1 Prueba t de una muestra 6.2 Prueba t de dos muestras 6.3 Prueba t de Welch 6.4 Prueba F de Fisher 6.5 Prueba t pareada 6.6 ANOVA (one-way-anova, two-way-anova) 6.7 ANCOVA 6.8 Correlación de Pearson 6.9 Regresión lineal simple y múltiple 6.10 Etc.", " Capítulo 6 Tipos de pruebas paramétricas 6.1 Prueba t de una muestra 6.2 Prueba t de dos muestras 6.3 Prueba t de Welch 6.4 Prueba F de Fisher 6.5 Prueba t pareada 6.6 ANOVA (one-way-anova, two-way-anova) 6.7 ANCOVA 6.8 Correlación de Pearson 6.9 Regresión lineal simple y múltiple 6.10 Etc. "],["tipos-de-pruebas-no-paramétricas.html", "Capítulo 7 Tipos de pruebas no paramétricas 7.1 Prueba de Mann-Whitney U (Wilcoxon rank-sum test) 7.2 Prueba de Wilcoxon para muestras relacionadas 7.3 Prueba de Kruskal-Wallis 7.4 Prueba de Friedman 7.5 Prueba de Chi-cuadrado (χ²) 7.6 Prueba de McNemar 7.7 Correlación de rango de Spearman 7.8 Correlación de Kendall (τ de Kendall)", " Capítulo 7 Tipos de pruebas no paramétricas 7.1 Prueba de Mann-Whitney U (Wilcoxon rank-sum test) 7.2 Prueba de Wilcoxon para muestras relacionadas 7.3 Prueba de Kruskal-Wallis 7.4 Prueba de Friedman 7.5 Prueba de Chi-cuadrado (χ²) 7.6 Prueba de McNemar 7.7 Correlación de rango de Spearman 7.8 Correlación de Kendall (τ de Kendall) "],["análisis-de-riqueza-y-diversidad-alfa-y-beta.html", "Capítulo 8 Análisis de riqueza y diversidad alfa y beta", " Capítulo 8 Análisis de riqueza y diversidad alfa y beta "],["análisis-multivariados.html", "Capítulo 9 Análisis multivariados 9.1 PCA 9.2 PCoA 9.3 NMDS 9.4 Permanova 9.5 permdis 9.6 Anosim 9.7 RDA 9.8 CCA", " Capítulo 9 Análisis multivariados 9.1 PCA 9.2 PCoA 9.3 NMDS 9.4 Permanova 9.5 permdis 9.6 Anosim 9.7 RDA 9.8 CCA "],["modelización-estadística.html", "Capítulo 10 Modelización estadística: 10.1 Modelo lineal general 10.2 GLM con distribución Poisson 10.3 GLM con distribución quasi-Poisson 10.4 GLM con distribución de Bernoulli (Binomial) 10.5 GLMM: modelos lineales generales mixtos", " Capítulo 10 Modelización estadística: 10.1 Modelo lineal general 10.2 GLM con distribución Poisson 10.3 GLM con distribución quasi-Poisson 10.4 GLM con distribución de Bernoulli (Binomial) 10.5 GLMM: modelos lineales generales mixtos "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
