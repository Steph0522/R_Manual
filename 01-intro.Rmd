#  Introducción a R y Rstudio


### Requisitos para la instalación de R

- R versión de 4.0 en adelante.
- Rstudio versiones 2024 en adelante.

### Instalación de Rsudio y R 

En caso de no tener instalado R y Rstudio y R que son los prerequisitosprerrequisitos para realizar  llevar a cabo los ejercicios de est e manuallibro, entonces debe visitar estas ligas los siguientes links para descargarlos e instalarlos. 


#### R 

- Para [MacOS](https://cran.r-project.org/bin/macosx/)
- Para [Ubuntu](https://cran.r-project.org/bin/linux/ubuntu/)
- Para [Windows](https://cran.r-project.org/bin/windows/base/)


####Rstudio 

- En [MacOS](https://download1.rstudio.org/electron/macos/RStudio-2024.12.1-563.dmg)
- En [Ubuntu](https://download1.rstudio.org/electron/jammy/amd64/rstudio-2024.12.1-563-amd64.deb)
- En [Windows](https://download1.rstudio.org/electron/windows/RStudio-2024.12.1-563.exe)



## Comenzando con R y RStudio {#getting-started}

```{r, include=FALSE, eval=FALSE}
if(knitr::is_html_output()){
  knitr::opts_chunk$set(out.width = "500pt",
                        out.extra='style="display: block; margin-left: auto; margin-right: auto; background-color: #000; padding:3pt;"')
} else{
  knitr::opts_chunk$set(out.width = "4in")
}
```

### Breve descripción de R

R es un lenguaje de programación como C o Java o Python pero enfocado principalmente a la estadística.
Cuando instalamos R en nuestra computadora, en realidad estamos instalando un entorno de programación, y para poder utilizarlo correctamente, necesitamos aprender a escribir las instrucciones de manera que el software pueda interpretarlas y ejecutarlas adecuadamenteCuando instalamos R en nuestra computadora en realidad lo que estamos instalando es el entorno computacional y para que podamos hacer uso de ese entorno necesitamos conocer la manera de escribir que el software pueda interpretar y ejecutar las instrucciones que le damos. Eso es lo que aprenderemos a hacer en este curso.  

Como en otros lenguajes de programación, en R podemos guardar nuestros proyectos de trabajo mediante un *script*, que poder ser ejecutado eventualmente y ser compartido con otros usuarios de R. 

 

### Un poco de historia...[^1]

[^1]: <https://bookdown.org/jboscomendoza/r-principiantes4/un-poco-de-historia.html>

R tiene su origen en el lenguaje de programación S, desarrollado en los Laboratorios Bell de Estados Unidos. Más tarde, en 1993, Ross Ihaka y Robert Gentleman, de la Universidad de Auckland en Nueva Zelanda, crearon una versión de S de código abierto y gratuita, lo que permitió su acceso y uso generalizado. No obstante, fue en el año 2000 cuando se lanzó una versión estable de R. Hoy en día, el desarrollo y mantenimiento del software están a cargo del R Development Core Team, un grupo internacional de expertos en ciencias computacionales y estadísticas, que provienen de diversas instituciones académicas y de investigaciónR proviene del lenguaje S, creado en los Laboratorios Bell (Estados Unidos). Los mismos que inventaron el transistor, el láser, el sistema operativo Unix y algunas otras cosas más. 

Ross Ihaka y Robert Gentleman, de la Universidad de Auckland de Nueva Zelanda, decidieron crear una implementación abierta y gratuita de S. Este trabajo, que culminaría en la creación de R inició en 1992 y no fue hasta el 2000 que se obtuvo una versión final estable. 

Hoy día, el mantenimiento y desarrollo de R es realizado por el R Development Core Team, un equipo de especialistas en ciencias computacionales y estadística provenientes de diferentes instituciones y lugares alrededor del mundo. 

R posee una Licencia Pública General de GNU, esto, para que pueda ser distribuido de manera gratuita, por lo que es software libre y de código abierto. Esta licencia también te permite usar R para los fines que desees, sin limitaciones, no importando si son personales, académicos o comerciales. 

### ¿Por qué usar R?[^2]

[^2]: <https://rafalab.github.io/dslibro/getting-started.html>

1.  R es gratuito y de código abierto[^3].
2.  Se ejecuta en todas las plataformas principales: Windows, Mac Os, UNIX/Linux.
3.  Los *scripts* y los objetos y los objetos de datos se pueden compartir sin problemas entre plataformas y usuarios.
4.  Existe una comunidad, creciente y activa de usuarios de R y, como resultado, hay numerosos recursos para aprender[^4] [^5].
5.  s fácil para otras personas contribuir con complementos (add-ons en inglés) o paquetes que les permiten a los desarrolladores compartir implementaciones de software relacionados ade nuevas metodologías de ciencia de datos. Esto les daaporta a los usuarios de R acceso directotemprano a los métodos y herramientas más recientes que se desarrollan para una amplia variedad de disciplinas, incluyendo la ecología, la biología molecular, las ciencias sociales y la geografía, entre otros campos.

[^3]: <https://opensource.org/history>

[^4]: <https://stats.stackexchange.com/questions/138/free-resources-for-learning-r>

[^5]: <https://www.r-project.org/help.html>

### RStudio {#rstudio}

RStudio será nuestra plataforma para los proyectos usados con el lenguaje R.
Nos provee un editor visual e interactivo para crear y editar nuestros *scripts*, además de otras herramientas útiles que iremos viendo con el pasar de los temas.

### Interfaz de Rstudio

Rstudio posee 4 paneles principales  (Figura 1):

1.  Enl el panel izquierdo superior aparece nuestro el editor de códigos. Es decir, comprende la sección donde se crean los  Donde ponemos los scripts que deber ser vamos a ejecutadoscorrer. 

2.  A la derecha, el panel superior incluye pestañas como Environment e History. La pestaña Environment (ambiente) muestra los nombres de todos los objetos (como vectores, matrices, bases de datos, etc.) creados en la consola. Por otra parte, la pestaña History le muestra un historial de todo el código que ha desarrollado previamente en la consolala derecha, el panel superior incluye pestañas como Environment y History, que son el ambiente y el historial, aquí podremos observar los objetos que vayamos declarando y data que subamos, además del historial de scripts. 

3.  A la derecha, el panel superior incluye pestañas como Environment e History. La pestaña Environment (ambiente) muestra los nombres de todos los objetos (como vectores, matrices, bases de datos, etc.) creados en la consola. Por otra parte, la pestaña History le muestra un historial de todo el código que ha desarrollado previamente en la consolala derecha, el panel superior incluye pestañas como Environment y History, que son el ambiente y el historial, aquí podremos observar los objetos que vayamos declarando y data que subamos, además del historial de scripts. 

4.  En el panel inferior derecho se muestran cinco pestañas: *File*, *Plots*, *Packages*, *Help* y *Viewer*. Pueden hacer clic en cada pestaña para moverse por las diferentes opciones. Pero a grandes rasgos, en file vemos donde nos encontramos situados y los archivos que hay en nuestro directorio. En plots se visualizan las imágenes que generamos, en packages los paquetes que poseemos instalados y cargados, en Help cuando necesitamos información extra de nuestros paquetes y en Viewer exploramos scripts de rmarkdown.

\

```{r, echo=FALSE, out.width="300pt", fig.align='center', fig.cap="Figure 1. Se representan los cuatro paneles de Rstudio"}

## http://ww2.coastal.edu/kingw/statistics/R-tutorials/install_help/R_console.png

img_path<- "images"

knitr::include_graphics(file.path(img_path, "Consola2.png"))
```

### *Scripts*

Una de las principales ventajas de R es la posibilidad de guardar los códigos y comandos mediante scripts. Un script es un archivo de texto que contiene una serie de instrucciones y comentarios. Para crear un nuevo script en R, solo tiene que hacer clic en "File", luego seleccionar "New File" y elegir "R Script". Esto abrirá un nuevo panel en la pantalla, donde podrá comenzar a escribir sus códigos y comentarios.Una de las grandes ventajas de R y Rstudio es que se pueden guardar los diversos códigos e instrucciones, los famosos conocidos como scripts, que entonces se pueden editar y guardar con un editor de texto. 


```{r, echo=FALSE,   out.width="50%", fig.cap="Figura 2. Representación gráfica de como abrir un nuevo script (File > New file > R script). "}
knitr::include_graphics(file.path(img_path,"script.jpeg"))
knitr::include_graphics(file.path(img_path,"script2.jpg"))

```

\

Podemos abrir y ejecutar scripts en R usando la función source(), dandoleindicando como argumento la ruta del archivo .R en nuestra computadora, o dar click en File > Open File y luego buscar la carpeta donde se encuentre entre comillas o yendo a File, entonces Open File y luego buscando en las carpetas donde tengas el script. 

Por ejemplo.

```{r, eval=FALSE}
source("C:/mi_script.R")

```

#### Cómo ejecutar comandos mientras se editan *scripts*

Para comenzar, abrimos un nuevo script y le asignamos un nombre. Esto se puede hacer guardando el script sin nombre a través del editor (Figura 3). Al guardar el script por primera vez, es importante usar un nombre descriptivo, en minúsculas, sin espacios y preferiblemente con guiones bajos ("_") para separar las palabras. Se deben evitar los guiones ("-"). Un ejemplo de nombre adecuado para el script podría ser: **"mi_script.R"**.Empezamos por abrir un nuevo script y luego nombramos el script. Podemos hacer esto a través del editor guardando el nuevo script actual sin nombre. Al guardar el script por primera vez use un nombre descriptivo, con letras minúsculas, sin espacios, preferiblemente con “_” para separar palabras, evitar guiones “-” para separar las palabras. Llamaremos a este script: **mi_script.R**. 
 

```{r, echo=FALSE, out.width= "300pt", fig.align='center', fig.cap="Con el editor de scripts como ventana activa, guarde y asigne un nombre a su archivo, junto con la extensión de archivo “. R”."}
knitr::include_graphics(file.path(img_path,"save.png"))

```

Ahora podemos editar nuestro primer script. Las primeras líneas de código se utilizan para agregar títulos o comentarios, los cuales se indican con el símbolo "#" al inicio de cada línea. A continuación, cargamos los paquetes y los datos que vamos a utilizar en el análisis. En una sección posterior, profundizaremos más sobre cómo cargar datos y paquetes de manera adecuada. Como ejemplo, utilizaremos la base de datos "Iris". Primero, cargamos la librería "datasets" y posteriormente los datos. Luego, obtendremos un resumen de los datos y, finalmente, creamos un gráfico boxplot. Para ejecutar cada línea de código, debemos hacer clic en el botón "Run" en la parte superior derecha del panel de edición. También se puede ejecutar una línea de código usando las combinaciones de teclas: Control+Enter en Windows y Linux, o Command+Return en Mac. 

 

Ejecute las siguientes líneas de código y obtenga los resultados provistos en la Figura 3:

```{r, eval=FALSE}
library(datasets)
data(iris)
summary(iris)
boxplot(iris)

```


```{r, echo=TRUE, out.width= "500pt",echo=FALSE, fig.align='center', fig.cap="Figura 3. Resumen (panel inferior izquierdo) y gráfico boxplot (panel inferior derecho) de la base de datos “Iris”. "}
knitr::include_graphics(file.path(img_path,"code.png"))

```

\

### Directorio de trabajo

El **directorio de trabajo** es la carpeta donde se encuentran los archivos (base de datos) que posteriormente son importados a R. Para saber cuál es la ubicación del directorio de trabajo use la siguiente función “getwd”. Para cambiar el directorio de trabajo, debe usar la función “setwd” y establecer la respectiva ruta (e.g. "/home/Desktop/”). Además, se puede conocer el contenido del directorio, utilizando las siguientes funciones “list.files” y “list.dirs”. 

```{r, eval=FALSE}
getwd()
```


```{r, eval=FALSE}
setwd("/home/steph/Desktop/")
```

```{r, eval=FALSE}
list.files()
list.dirs()
```

### Sesión

En R, los objetos y funciones se almacenan en la memoria durante una sesión y no se comparten entre sesiones. Cada vez que inicia R, se crea una nueva sesión. Debe guardar los objetos generados durante la sesión, ya que los scripts se guardan automáticamente, pero no los objetos. Estos se guardan en un archivo **.RData** en su directorio de trabajo. Para ver todos los objetos guardados, utilice la función *ls*. En la Figura 4 se muestra cómo crear un nuevo proyecto en R. 

```{r, echo=FALSE, out.width= "400pt", echo=FALSE, fig.align='center', fig.cap="Figura 4."}
knitr::include_graphics(file.path(img_path,"new_directory.png"))
```

### Proyecto

Un proyecto de R (con extensión .Rproj) es una carpeta que contiene todos los archivos y recursos relacionados. Dentro del proyecto, los scripts, archivos de datos, resultados e historial se organizan en subcarpetas, lo que facilita la gestión del trabajo. Al crear un proyecto, todos los archivos quedan vinculados, lo que mejora la organización y el flujo de trabajo. Para crear un proyecto debe realizar los siguientes pasos (XX > XY > XZ; ver Figura XX):Un proyecto de R (extensión .Rproj) identifica todos los archivos y contenido asociado con él. Ayuda a organizar tu trabajo y así cada curso, artículo o trabajo diferente puede tener un proyecto diferente. Al crea


\

```{r, echo=FALSE, out.width= "400pt", echo=FALSE, fig.align='center', fig.cap="Figura 5."}
knitr::include_graphics(file.path(img_path,"new_directory2.png"))
```

\

```{r, echo=FALSE, out.width= "400pt", echo=FALSE, fig.align='center', fig.cap="Figura 6."}
knitr::include_graphics(file.path(img_path,"new_directory3.png"))
```

\

### Instalación de paquetes de R
Una de las principales ventajas de R es que numerosos desarrolladores y programadores crean paquetes continuamente, los cuales están disponibles de forma gratuita y ofrecen diversas funcionalidades. Actualmente, existen muchos paquetes accesibles a través de CRAN (Comprehensive R Archive Network), una red global de servidores que proporcionan versiones actualizadas. Además, se pueden encontrar numerosos paquetes en plataformas como GitHub y Bioconductor. Un ejemplo de ello es el paquete tidyverse, muy útil y que exploraremos en sesiones posteriores. Para instalarlo, utilice el siguiente códigoDentro de las ventajas de R está que muchos desarrolladores y programadores elaboran constantemente complementos, aplicaciones o en palabras propias paquetes que nos permiten usar en acceso libre y que tienen muchas funcionalidades. Actualmente hay muchos disponibles en CRAN (Comprehensive R Archive Network) que es una red de servidores alrededor del mundo que almacena versiones actualizadas del código de R y su documentación. También hay muchos paquetes desarrollados publicados en GitHub y en Bioconductor. Por ejemplo para instalar el paquete tidyverse, que es de gran utilidad y que veremos en sesiones posteriores, usamos el código: 

```{r,eval=FALSE}
install.packages("tidyverse")
```

En RStudio, se puede ir a la pestaña "Packages" y hacer clic en "Install". Luego, debe escribir el nombre del paquete que desea instalar, siempre y cuando esté disponible en CRAN. Para cargar una librería utilice la función “library()”En RStudio pueden navegar a la pestaña Pakages y seleccionar Install. Luego, escribir el paquete que queremos siempre y cuando esté en CRAN. Para cargar una librería como lo vimos anteriormente se usa la función, **library()**: 

```{r, eval=FALSE}
library(tidyverse)
```
Una vez que se instalaninstalados los paquetes, no debenn instalarselo nuevamentede nuevo., Ssin embargo, cada vez que cerramos o reiniciamos sesión, reiniciamos sesión o abrimos un nuevo proyecto o sesión tenemos que volver a cargarlos. Además,  

dDebemos tener en cuenta que la instalación de tidyverse instala incluye varios paquetes. Esto ocurre comúnmente cuando un paquete tiene dependencias, es decir, usa funciones de otros paquetes. Cuando cargan un paquete usando library, también cargan sus dependencias.  

Hay paquetes que no se encuentra en CRAN, por lo tanto o que si queremos su versión en desarrollo, se necesitan de otros paquetes para ser instalados. , Ppor ejemplo, si queremos instalar la versión en desarrollo del paquete “rmarkdown”, que se encuentra en github, se utiliza el paquete devtools. Los dos puntos “::” se usan para llamar a una función de un paquete sin cargar el paquete completamente en la sesión.: 

```{r, eval=FALSE, echo=TRUE}
devtools::install_github('rstudio/rmarkdown')
```


### Tipos de objetos en R

a información que manipulamos en R se estructura en forma de objetos y los podemos ver almacenados en el panel del ambiente de trabajo o Enviroment. Una ventaja de los lenguajes de programación es la posibilidad de definir variables y escribir expresiones matemáticas para almacenar valores que se usarán eventualmente. En R, usamos <- para asignar valores a las variables. Aunque también se puede usar =, pero se recomienda evitarlo, ya que el signo = se utiliza para igualdad lógica, lo que podría generar confusión. Los objetos pueden ser de diferentes tipos: 

-   Números escalares o letras

-   Vectores y matrices

-   Dataframes, tablas y listas

Más adelante detallaremos este tipo de objetos o datos en R. Aquí unos ejemplosEn las siguientes líneas de comando se puede observar algunos tipo de objetos: 

```{r}

a <- 1                                                          #escalar
letra <- "a"                                                    #caracter o letra
b <- c(1,2,3)                                                   #vector
c<- matrix(1:10)                                                #matriz
d<- data.frame(Especie=c("A", "B"), Longitud=c(c(1,2)))         #dataframe o tabla
e<- list(c(1:20), c(1:10))                                      #lista
```

 

Para visualizar ver la información el valor almacenadao en un objetouna variable, simplemente le pedimos a R que evalúe a y R nos muestra el valor almacenadoesa información mediante la función print o escribiendo directamente el objeto creado. Por Ejemplo: 

```{r}
a
```

Una forma explícita de pedirle a R que nos muestre el valor almacenado en `a` es usar `print` así:

```{r}
print(a)
```

Otra forma de examinar los objetos es buscarlos en el *Enviorment* o ambiente de trabajo y visualizarlos desde allí.
Deberíamos ver `a`, `b` y las que ya hemos declarado en el ambiente.
Si intentamos imprimir o visualizar el valor de un objeto que no está definido en el ambiente se recibirá un mensaje de error.
Por ejemplo, si escriben `f`, verán lo siguiente: `Error: object 'f' not found`.

##### Algunos tips para asignar variables u objetos en R...

-   Los nombres de variables tienen que comenzar con una letra, no pueden contener espacios y no deben ser variables predefinidas en R (como funciones o argumentos de funciones).
    Por ejemplo, no nombren una de sus variables `install.packages` escribiendo algo como: `install.packages <- 2`.
    Esto reescribe la función o causa confusiones para R.

-   Que tus nombres sean descriptivos y/o significativos para lo que se está almacenado, usar solo minúsculas y usar guiones bajos *( \_ )* como sustituto de espacios, evitar caracteres especiales (- ; . \@ ?) .

#### Guardar los espacios de trabajo y exportar objetos de R

Los objetos evaluados permanecen en el espacio de trabajo hasta que finalicen sus sesiones sin guardar.
Pero los espacios de trabajo también se pueden guardar para su uso posterior.
De hecho, al salir de R, el programa les pregunta si desean guardar su espacio de trabajo.
Si lo guardan, la próxima vez que inicien R, el programa restaurará el espacio de trabajo con todos los objetos en él.

Sin embargo, no se recomienda guardar el espacio de trabajo porque sino se trabaja con diferentes proyectos, será más difícil darle seguimiento de lo que guardan y ocupara mucho espacio en la memoria de su disco.
En cambio, se recomienda en gran medida realizar un proyecto por trabajo o tarea y así tener un espacio de trabajo para cada uno.
Decidiendo o no si guardar las sesiones y no entrar en confusiones entre las diferentes sesiones.

Ahora bien R ya posee funciones de exporte, tales como:

```{r, eval=FALSE}
library(readr)
write_tsv(d, "data.tsv")
write.table(d, "data.txt", sep = "\t")
write_csv(d, "data.csv")
```

Estas funciones guardan tus tablas u objetos con formatos de texto.
También hay una forma de guardar objetos de R sin declararlos como texto sino que se queden con la identidad de R:

```{r, eval=FALSE}
saveRDS(d, "data.RDS")
```

Y para abrir o cargar este tipo de objetos con extensión .RDS usamos la siguiente función:

```{r, eval=FALSE}
readRDS("data.RDS")
```

### Funciones en R[^6]

[^6]: <https://rafalab.github.io/dslibro/r-basics.html#>

Una vez que definidos los objetos o las variables, si queremos continuar con el análisis de datos generalmente se usan una serie de funciones específicas que se aplican a las variables o datos.
R incluye muchas funciones por *default* o preestablecidas y otras pueden extraerse al cargar los diversos paquetes.
A lo largo de este curso ya hemos usado varias funciones tales como las funciones para exportar datos como *write_csv()* o para cargar paquetes tales como *library()*, entre otras.
Hay otras funciones más sencillas como por ejemplo la función `log` o `sqrt` con las que podemos obtener el logaritmo o la raíz cuadrada.
***(Nótese que las funciones en su gran mayoría están definidas en inglés)***.

Muchas otras funciones vienen establecidas en otros paquetes como fue el caso que vimos de *read_csv()* del paquete *readr*.
La sintaxis o el lenguaje de R nos indica que necesitas usar paréntesis para evaluar funciones como hemos visto en los ejemplos anteriores que hemos usado funciones.
Algunas funciones como *ls()* no requieren argumentos sino que nos da la información que ocupamos sin evaluar nada dentro de los paréntesis.
Sin embargo, en otras funciones sí requieren uno o más argumentos.
A continuación se muestra un ejemplo de cómo asignamos un objeto al argumento de la función `log`.
Recuerden que anteriormente definimos `a` como 1:

```{r}
log(a)
```

Podemos explorar funciones en el panel inferior derecho en la pestaña de *Packages* o *Paquetes* podemos explorar los paquetes y al hacer click en alguno nos despliega las funciones que posee y su documento de ayuda también.
Se puede saber cuáles son los argumentos de la función o lo que la función espera o las opciones que tiene, con el comando *help* o también anteponiendo un signo *?* antes de la función.
También mientras escribimos la función si usamos la tecla *tab* nos indica también que argumentos espera esta función.
Pueden averiguar lo que la función espera y lo que hace revisando unos manuales muy útiles incluidos en R.
Pueden obtener ayuda utilizando la función `help` así:

```{r, eval=FALSE}
help("log")
?log
```

La página de ayuda les mostrará qué argumentos espera la función.
Por ejemplo, `log` necesita `x` y `base` para correr.
Sin embargo, algunos argumentos son obligatorios y otros son opcionales.
Pueden determinar cuáles son opcionales notando en el documento de ayuda cuáles valores predeterminados se asignan con `=`.
Definir estos es opcional.
Por ejemplo, la base de la función `log` por defecto es `base = exp(1)` que hace `log` el logaritmo natural por defecto.

Para echar un vistazo rápido a los argumentos sin abrir el sistema de ayuda, pueden escribir:

```{r}
args(log)
```

Pueden cambiar los valores predeterminados simplemente asignando otro objeto:

```{r}
log(x = 8, base = 2)

```

El código anterior funciona, pero también podemos ahorrarnos un poco de escritura: si no usan un nombre de argumento, R supone que están ingresando argumentos en el orden en que se muestran en la página de ayuda o por `args`.
Entonces, al no usar los nombres, R supone que los argumentos son `x` seguido por `base`:

```{r}
log(8,2)
```

Si se usan los nombres de los argumentos, podemos incluirlos en el orden en que queramos:

```{r}
log(base = 2, x = 8)
```

Para especificar argumentos, debemos usar `=` y no `<-`.
Aquí si aplica la igualdad, en el caso de las funciones.

Hay algunas excepciones a la regla de que las funciones necesitan los paréntesis para ser evaluadas.
Entre estas, las más utilizados son los operadores aritméticos y relacionales.
Por ejemplo:

```{r}
a + a
a - 2
1 * pi
2 / 3
4 ^ a
```

También es posible declarar una función que a lo mejor no esté definida en R.
Por ejemplo, la función *mean()* en Rbase nos da el promedio de un conjunto de datos, pero si quisieramos definirla en caso de no conocerla o hacerlo a nuestra manera, sería algo así:

```{r}
average<- function(x){sum(x)/length(x)}
x<- 1:100
average(x)
mean(x)
```

Al compararlas nos arrojan el mismo valor.
Lo importante de este punto es que hemos declarado una nueva función, declarando primero la variable (o variables, dependiendo el caso) y luego las operaciones y asignandolos a un objeto de R:

```{r, eval=FALSE}
nombre <- function(argumentos) {
  operaciones}
```

Para trabajar con R resulta importante conocer los principales tipos de objetos y sus propiedades básicas.

## Tipos de datos

Como vimos en el ejemplo anterior, los objetos en R pueden ser de varios tipos.
Por ejemplo, necesitamos distinguir números de los caracteres.
La función `class` nos ayuda a determinar qué tipo de objeto tenemos:

```{r}
a <- 5
class(a)
```

| Tipo                   | Nombre en inglés/en R | Ejemplo     |
|------------------------|-----------------------|-------------|
| Numérico               | numeric               | 5.1         |
| Entero                 | integer               | 4           |
| Real                   | double/float          | 3.4         |
| Cadena de texto, letra | character             | "a"         |
| Factor                 | factor                | Bajo        |
| Lógico                 | logic                 | TRUE, FALSE |
| Perdido/Omitido        | NA                    | NA          |
| Vacío                  | null                  | NULL        |

Existen otro tipos de datos más complejos que no están en el alcance del presente curso, por ejemplo: números complejos, fechas, entre otros.

#### Para tener en cuenta...

-   El tipo *character* representa texto y es fácil reconocerlo porque un dato siempre esta rodeado de comillas, simples o dobles.
    Este es el tipo de datos más flexible de R, pues una cadena de texto puede contener letras, números, espacios, signos de puntuación y símbolos especiales.

-   Un factor es un tipo de datos específico a R.
    Puede ser descrito como un dato numérico representado por una etiqueta.
    Por último, cada una de las etiquetas o valores que puedes asumir un factor se conoce como **nivel** o **level**.
    los niveles tienen un orden diferente al orden de aparición en el factor.
    En R, por defecto, los niveles se ordenan alfabéticamente.
    **Advertencia**: Los factores pueden causar confusión ya que a veces se comportan como caracteres y otras veces no.
    Como resultado, estos son una fuente común de errores.
    A veces las funciones necesitan a fuerza que se ocupe un vector y a veces lo contrario.

-   La diferencia entre las dos es que un dato `NULL` aparece sólo cuando R intenta recuperar un dato y no encuentra nada, mientras que `NA` es usado para representar explícitamente datos perdidos, omitidos o que por alguna razón son faltantes.
    `NA` además puede aparecer como resultado de una operación realizada, pero no tuvo éxito en su ejecución.

#### Coerción de datos...

En R, los datos pueden ser coercionados, es decir, forzados, para transformarlos de un tipo a otro.

| Función de coerción | Tipo     |
|---------------------|----------|
| as.integer()        | Entero   |
| as.numeric()        | Numérico |
| as.character()      | Caracter |
| as.factor()         | Factor   |
| as.logical()        | Lógico   |

Veamos algunos ejemplos:

```{r}
a<- 5
as.character(a)
as.factor("medio")
```

### Tipos de estructura de los datos

Los datos se estructuran de diferentes formas dependiendo de su propósito, en todo caso, la función *class()* también nos puede dar información sobre los tipos de estructuras de datos.

#### Vectores

Los vectores son colecciones de uno o más datos del mismo tipo.
Por ejemplo, si tenemos un vector con datos numéricos tenemos un vector de tipo numérico.
No es posible mezclar datos de tipos diferentes dentro de ellos.
Por ejemplo, un vector de colores puede ser:

```{r}
colores<- c("red", "black", "blue")
is.vector(colores)
class(colores)
```

Al usar las funcion `is.vector()` corroboramos que efectivamente es un vector al darnos `TRUE` pero al pedirle que nos indique el tipo con la función `class` nos dice que es un "character" es decir que es un vector de una cadena de texto.

Existen algunas operaciones al aplicarlas a un vector, se aplican a cada uno de sus elementos.
A este proceso le llamamos **vectorización**.
Las operaciones aritméticas y relacionales pueden vectorizarse.
Si las aplicamos a un vector, la operación se realizará para cada uno de los elementos que contiene.

```{r}
un_vector <- c(1:10)
un_vector*10
un_vector+1
un_vector + un_vector

```

#### Matrices y arreglos

Las matrices y arreglos no son más que vectores multidimensionales, es decir un conjunto de vectores.
Al igual que un vector deben contener un sólo tipo de datos.
En sentido estricto, una arreglo es una matrix pero con `n` dimensiones, mientras que las matrices tienen solo dos dimensiones.
Las matrices y los arreglos suelen ser usados de manera regular en matemáticas y estadística, por ser sencillas y contener solo un tipo de datos (usualmente de tipo numérico).
En general, es preferible usar listas en lugar de arrays, una estructura de datos que además tienen ciertas ventajas que se revisará más adelante.
En R, podemos usar el símbolo `:` para indicar una secuencia de números que tiene un principio y fin, por ejemplo:

```{r}
vect<- 1:20
```

Este es un vector con números que va desde el 1 al 20.
Pero para hacerlo matriz hacemos:

```{r}
matr<- matrix(1:20)
```

O para dividirlo en varias renglones y columnas:

```{r}
matri<-matrix(1:20, nrow = 5, ncol = 4)
dim(matri)
matri

```

Con la función *dim()* podemos saber cuales son las dimensiones (es decir, largo y ancho) de nuestra matriz.
Las operaciones aritméticas también son vectorizadas al aplicarlas a una matriz.
La operación es aplicada a cada uno de los elementos de la matriz al igual que los vectores.

```{r}
matri*2
```

Algo más que podemos hacer es tranponer una matriz para rotarla 90°.

```{r}
t(matri)
```

#### Listas

Las listas, al igual que los vectores, son estructuras de datos unidimensionales, sólo tienen largo, pero a diferencia de los vectores cada uno de sus elementos puede ser de diferente tipo o incluso de diferente clase, por lo que son estructuras heterogéneas.
Podemos tener listas que contengan escalares, vectores, matrices, data frames u otras listas.
Para crear una lista usamos la función list(), que nos pedirá los elementos que deseamos incluir en nuestra lista.
Para esta estructura, no importan las dimensiones o largo de los elementos que queramos incluir en ella.
Al igual que con un data frame, tenemos la opción de poner nombre a cada elemento de una lista.

```{r}
un_vector <- 1:20
una_matriz <- matrix(1:4, nrow = 5)
una_df     <- data.frame("numeros" = 1:3, "letras" = c("a", "b", "c"))

una_lista <- list("vector" = un_vector, "matriz" = una_matriz, "df" = una_df)

una_lista
```

No es posible vectorizar operaciones aritméticas usando listas.
Al intentarlo nos es devuelto un error.

Finalmente, en caso de que sea necesario utilizar funciones que requieran a fuerza una matrix o un *data frame* también aplica la coerción entre estas dos estructuras de datos:

```{r}
coerción_df<- as.data.frame(una_matriz)
coerción_mat<- as.matrix(una_df)

class(coerción_df); class(coerción_mat)

```

Esta coerción es muy útil por ejemplo al utilizar la función `t()` que transponer una *data frame*:

```{r}
df_transpuesta<- t(una_df)
class(df_transpuesta)
```

Como vemos la función `t()` cambia la estructura de los datos, para evitar esto, coercionamos esta salida.

```{r}
df_transpuesta<- as.data.frame(t(una_df))
class(df_transpuesta)

```

## *Data frames*

La forma más común de almacenar un set de datos en R es usando un *data frame*.
Los data frames son estructuras de datos de dos dimensiones (rectangulares) que pueden contener datos de diferentes tipos, por lo tanto, son heterogéneas.
Podemos entender a los data frames como una versión más flexible de una matriz.
Mientras que en una matriz todas las celdas deben contener datos del mismo tipo, los renglones de un data frame admiten datos de distintos tipos, pero sus columnas conservan la restricción de contener datos de un sólo tipo.

Vamos a trabajar con una data de ejemplo y exploraremos esta *data frame*, es una data en la que evaluan el efecto de la dosis de vitamina C sobre el crecimiento de los dientes de unos tipos de cerdos.
La función `str` es útil para obtener más información sobre la estructura de un objeto:

```{r, echo=TRUE}
data(ToothGrowth)
str(ToothGrowth)
```

Esto nos dice mucho más sobre el objeto.
Vemos que la tabla tiene 60 filas y 3 variables.
Podemos mostrar las primeras seis líneas usando la función `head`:

```{r}
head(ToothGrowth)
```

Para crear un data frame usamos la función *data.frame()*.
Esta función nos pedirá un número de vectores igual al número de columnas que deseemos.
Todos los vectores que proporcionemos deben tener el mismo largo.
Es decir, un data frame está compuesto por vectores.
Veamos un ejemplo:

```{r}
df <- data.frame(
  "entero" = 1:3, 
  "factor" = c("alto", "medio", "bajo"), 
  "letras" = as.character(c("a", "b", "c"))
)

df
dim(df)
```

La función `dim` nos permite conocer también las dimensiones de nuestra data frame.
En este caso tenemos 3 filas y 3 columnas.
Las funciones `names` y `colnames` nos permiten conocer los nombres de los headers o de las columnas.

```{r}
names(df)
colnames(df)
```

### El operador `$` y otras formas de acceso

Para tener acceso a las diversas variables o columnas de un *data.frame* utilizamos el operador de acceso `$`, por ejemplo, si quisieramos tener acceso a la variable 'factor' de la *data.frame* **df** de la siguiente manera:

```{r}
df$factor
class(df$factor)
is.vector(df$factor)
```

Cuando usamos el operador `$` el tipo de objeto que obtenemos es un vector, en el ejemplo como la columna 'factor' es una cadena de caracteres entonces al usar las funciones *class()* y *is.vector()* nos confirma lo antes mencionado.

**Tip**: R viene con una muy buena funcionalidad de autocompletar que nos ahorra la molestia de escribir todos los nombres.
Escriban `df$f` y luego presionen la tecla *tab* en su teclado.
Esta funcionalidad y muchas otras características útiles de autocompletar están disponibles en RStudio, esto aplica también para las funciones.

En el caso de las listas también podemos acceder con el operador `$`, aunque también podemos usar corchetes dobles (`[[`) así.
Por ejemplo declaramos una lista:

```{r}
notas_estudiantes <- list(nombres = c("Ana", "Clara", "Sofy"),
               id_estudiante = c("i1", "i2", "i3"),
               notas = c(10, 9,7))
```

Y queremos extraer los nombres de los estudiantes, entonces hacemos\_

```{r}
notas_estudiantes$nombres
notas_estudiantes[["nombres"]]
```

Y obtenemos el mismo resultados.

Para el caso de las matrices se puede acceder usando corchetes (`[`).
Si desean la primera fila y la pimera columna, entonces:

```{r}
mat<- matrix(1:10, ncol = 2, nrow = 5)
mat[1,1]
mat
```

Para acceder solo a la primera fila y solo a la primera columa usamos las comas, así: s

```{r}
mat[1, ] #acceder primera fila
mat[, 1] #acceder a la primera columna
is.vector(mat[, 1])
```

Notese que esto devuelve un vector, no una matriz.

Del mismo modo, si desean la segunda columna completa, dejen el lugar de la fila vacío:

```{r}
mat[, 2]
```

Esto también es un vector, no una matriz.
Lo corroboramos con la función *is.vector()*

Se pueden crear subconjuntos basados tanto en las filas como en las columnas:

```{r}
mat[2:4 , 1:2]  #en orden de posición es filas primero y luego columnas
```

Podemos convertir las matrices en *data frames* usando la función `as.data.frame`:

```{r}
as.data.frame(mat)
```

## Creando subconjuntos o Indexación.

En R, podemos obtener subconjuntos de nuestras estructuras de datos.
Es decir, podemos extraer partes de una estructura de datos (nuestro conjunto).

También podemos usar corchetes individuales (`[`) para acceder a las filas y las columnas de un *data frame* y es exactamente igual que lo que se aplicó con las matrices.
A esto es lo que llamamos **Subconjuntos** de los *data.frame*.
Como las listas de datos que usamos para *notas_estudiantes* tienen las mismas dimensiones entonces podemos coercionarlo a ser una *data.frame*:

```{r}
evaluaciones<- as.data.frame(notas_estudiantes)
```

Y para obtener más de una entrada se puede utilizar un vector de entradas múltiples como índice:

```{r}
evaluaciones[c(1,2)]
```

Obtenemos las dos primeras columnas.
Las secuencias definidas anteriormente son particularmente útiles si necesitamos acceso, digamos, a los dos primeros elementos:

```{r}
evaluaciones[1:2]
```

Ahora bien, si queremos **NO** elegir por ejemplo la primera columna o dejarla por fuera, entonces usamos el signo **'-'**:

```{r}
evaluaciones[,-1]
```

Si los elementos tienen nombres de columna o *headers* también podemos acceder a las entradas utilizando estos nombres:

```{r}
evaluaciones[c("nombres","notas")]
```

Ahora bien, podemos seleccionar datos que tengan características específicas, por ejemplo, todos los valores mayores a cierto número o aquellos que coinciden exactamente con un valor de nuestro interés.
Para realizar esta operación haremos uso de índices y operadores lógicos.

| Operador | Comparación           |
|----------|-----------------------|
| \<       | Menor que             |
| \<=      | Menor o igual que     |
| \>       | Mayor que             |
| \>=      | Mayor o igual que     |
| ==       | Exactamente igual que |
| ! =      | No es igual que       |
| !        | No es                 |
| =        | Igual que             |
| &, \|    | y, ó                  |

Por ejemplo en el caso de la tabla de **evaluaciones**, si queremos escoger los valores que sean mayor de 8 en las notas obtenidas:

```{r}
evaluaciones$notas > 8
```

Observamos cuales cumplen con la condición si muestran `TRUE`.
Ahora para usar este filtro y hacer un subconjunto con el *data.frame*, hacemos:

```{r}
mas_de_8<-evaluaciones[evaluaciones$notas > 8,]
mas_de_8
```

Si queremos usar más de una condición pero indicando negación:

```{r}
evaluaciones[!(evaluaciones$notas > 8 & evaluaciones$nombres == "Clara"), ]

```

Para escoger un valor que sea exactamente igual a una condición usamos '==':

```{r}
evaluaciones[evaluaciones$nombres == "Sofy",]

```

### Importando datos {#importing-data}

```{r, echo=FALSE}
img_path <- "images/"
```

Para el ejemplo que vimos en el capítulo pasado usamos un dataset que está en el ambiente de R por default, si queremo saber cuales son los datasets que tenemos en nuestro ambiente, podemos usar el comando *data()* y nos desplegará la lista:

```{r}
data()
```

Si queremos utilizar los datos de nuestro trabajo o usar datos de una base de datos o que de una 'dataset' que se encuentre en internet, debemos *Importar* estos datos a nuestra sesión de R.
Usualmente tenemos nuestros datos guardados en hojas de cálculo en diferentes formatos con diferentes extensiones, estos son los más populares:

-   separados con *coma* o *punto y coma* (`,`,`;`): csv,

-   separados con tabulaciones o espacios (*tab,* `\t`) : .txt o .tsv,

-   Hojas de cálculo de excel: .xls, son las más usadas.

A continuación muestro una imagen de como se ven un .csv y .txt:

```{r, echo=FALSE, out.width= "400pt", fig.align='center'}
knitr::include_graphics(file.path(img_path,"files.png"))
```

## El directorio de trabajo y rutas

Antes de importar nuestros propios archivos, tablas o datos debemos estar seguros en qué directorio nos encontramos, para estar seguros que vamos a importar el archivo deseado a R.

Existen tres opciones para esto:

1.  Utilizar **getwd()** y **setwd()**, como lo vimos anteriormente, para establecer y saber en qué directorio nos encontramos y si es el caso, cambiarlo.

2.  Poner la ruta completa de nuestro archivo, sin importar donde esté.

3.  Utilizar **"Import Dataset"** de nuestro panel de ambiente y ubicar manualmente la ubicación del archivo.

El reto de la primera opción es permitir que las funciones de importación de R sepan dónde buscar el archivo que contiene los datos.
La forma más sencilla de hacer esto es tener una copia del archivo en la carpeta donde las funciones de importación buscan por defecto, es decir guardar este archivo en nuestro directorio de trabajo.

### Descargando un archivo de la web

Para descargar algún archivo en la web a utilizar, podemos correr el siguiente código:

```{r, eval=FALSE}
download.file(
  url = "https://raw.githubusercontent.com/sagar3122/Machine-Learning/refs/heads/master/iris.data.txt", 
  destfile = "iris.data")

```

Si observamos nuestros archivos en nuestro directorio de trabajo con el código *list.files()* veremos que se encuentra esta data que hemos descargado.

El código anterior no lee los datos sólo, en este caso, descarga la data.
Otra forma de descargarlo y a la vez abrirlo es de la siguiente manera, con el paquete *readr*:

```{r, warning=FALSE, message=FALSE}
iris_dat<-readr::read_csv("https://raw.githubusercontent.com/sagar3122/Machine-Learning/refs/heads/master/iris.data.txt")
```

## Funciones de importación

Una vez descargado o que se encuentre en nuestro directorio de trabajo, podemos importar los datos con solo una línea de código.
Aquí usamos la función `read.csv` o `read.delim` de R base (que viene default cuando descargamos R).

```{r, eval=FALSE}
iris_data<- read.csv("iris.data", header = F)
iris_data<- read.delim("iris.data",header = F, sep = ",")
```

Los datos se importan y almacenan en el obejto `iris_dat`.
Los argumentos *header = F* y *sep=","* son parámetros extras que podemos agregar a la función para indicarle algunas cosas.
Por ejemplo *header=F*, le estamos diciendo que la prima fila no contiene los títulos o *headers* de la tabla, en caso de que si fuera así, le daríamos *TRUE*.
Podemos usar la tecla *'tab'* para explorar las demás opciones que podemos utilizar en estas funciones.

También el paquete *readr* tiene otras funciones de importación muy parecidas:

```{r, warning=FALSE, message=FALSE}
library(readr)
iris_data<-read_csv("iris.data", col_names = c("Longitud.sepalo", "Ancho.Sepalo" ,
                                               "Longitud.Petalo" ,"Ancho.Petalo" , "Especies"  ))
```

En esta función usamos el argumento *col_names* para establecer los *Headers* o nombre de las columnas de esta tabla.

La segunda opción que vimos es utilizar la ruta completa del archivo, por ejemplo:

```{r}
data<- read_csv("Data/penguins_size.csv")
```

\

En este ejemplo, la data que importamos está ubicada en la carpeta de 'Data' de este proyecto.
Y vemos que esta función de *readr* también nos da información del archivo como el tipo de variable y el nombre de las mismas.

La última opción, un poco más fácil para algunos y más interactiva es usar *Import Dataset* del planel del ambiente.

```{r, echo=FALSE, out.width= "500pt", fig.align='center'}
knitr::include_graphics(file.path(img_path,"import.png"))

```

En esta opción podemos importar tablas con cualquiera de las funciones que despliega dependiendo del tipo de archivo, yo recomiendo si es .csv o .txt usar *readr* que es el mismo que usa tidyverse, como lo vimos anteriormente.
Paquete que veremos más detalladamente junto con *readxl* en la siguiente sección.



### Los paquetes readr y readxl[^1]

[^1]: <https://rafalab.github.io/dslibro/importing-data.html>

#### readr

El paquete **readr** un paquete de tiyverse, tiene las siguientes funciones para importar arvhivos con diferentes extensiones:

+------------+---------------------------------------------------------------+----------------+
| Función    | Tipo de archivo                                               | Extensión      |
+============+===============================================================+================+
| read_table | valores separados por espacios en blanco                      | txt            |
+------------+---------------------------------------------------------------+----------------+
| read_csv   | valores separados por comas                                   | csv            |
+------------+---------------------------------------------------------------+----------------+
| read_csv2  | valores separados por punto y coma                            | csv            |
+------------+---------------------------------------------------------------+----------------+
| read_tsv   | valores separados delimitados por tab                         | tsv o txt      |
+------------+---------------------------------------------------------------+----------------+
| read_delim | formato de archivo de texto general, debe definir delimitador | txt, csv o tsv |
+------------+---------------------------------------------------------------+----------------+

#### readxl

Este paquete ofrece funciones para leer archivos provienetes de Microsoft Excel:

| Función    | Formato                             | Sufijo típico |
|------------|-------------------------------------|---------------|
| read_excel | detectar automáticamente el formato | xls, xlsx     |
| read_xls   | formato original                    | xls           |
| read_xlsx  | nuevo formato                       | xlsx          |

### Algunos tips para hojas de cálculo de excel...

-   Evitar cosas como tener muchos diferentes formatos (colores, subrayados, etc).
-   Evitar en lo posible celdas vacías y poner un dato en cada celda
-   Evitar celdas con cálculo o aplicación de fórmulas.
-   Tenga en cuenta que nuestros datos que tenemos en hojas de cálculo en excel también podemos guardarlos en otros formatos un poco más fáciles para ser importados como los que ya vimos (.csv y .txt). Esto utilizando la opción *Guardar como* y escogiendo el tipo de formato deseado. En la imagen podemos ver un ejemplo de esto:

```{r, echo=FALSE, out.width= "350pt", fig.align='center'}
knitr::include_graphics(file.path(img_path,"saveexcel.jpg"))

```

## Algunas funciones Básicas de R

### `sort` y `order`

Digamos que queremos clasificar las notas de la mayor a la menor, podemos usar alguna de estas dos funciones:

```{r}
sort(evaluaciones$notas)
```

```{r}
order(evaluaciones$notas)
```

### `max` y `which.max`

Si solo estamos interesados en la entrada con el mayor valor, podemos usar `max`:

```{r}
max(evaluaciones$notas)
```

y `which.max` nos dice que valor es el mayor, posicionalmente:

```{r}
which.max(evaluaciones$notas)
```

Para el mínimo, podemos usar `min` y `which.min` del mismo modo.

### `which`

La función `which` nos dice qué entradas de un vector lógico son TRUE.
Entonces podemos escribir:

```{r}
ind <- which(evaluaciones$nombres == "Ana")
ind
evaluaciones[ind,]
```

De esta forma también podemos usarlo para filtrar y hacer subconjuntos.

### `match`

La función `match` nos dice qué índices de un segundo vector coinciden con cada una de las entradas de un primer vector:

```{r}
v1<- c("Uvas", "Peras", "Mandarinas", "Plátanos", "Manzanas")
v2<- c("Uvas","Cerezas", "Mandarinas", "Naranjas", "Manzanas") 
match(v1, v2)
match(c("Peras", "Plátanos"), v1)
ind<-match(c("Peras", "Plátanos"), v1)
v1[ind]
```

Este filtro puede aplicarse de igual manera a un *data.frame*:

```{r}
ind2<- match(v1, v2)
frutas<- data.frame(persona1=v1,persona2=v2)
frutas[ind,]
na.omit(frutas[ind2,])     #na.omit() nos permite quitar las celdas que contienen NA's
```

### `%in%`

Si en lugar de un índice queremos un lógico que nos diga si cada elemento de un primer vector está en un segundo vector, podemos usar la función `%in%`.
Siguiendo el ejemplo pasado:

```{r}
c("Peras", "Plátanos") %in% frutas$persona1
```

Nos dice que los dos elementos qu buscamos están presente en el *data.frame()*

**Avanzado**: `match` y `%in%` pueden dar el mismo output usando `which`:

```{r}
match(c("Peras", "Plátanos"), frutas$persona1)
which(frutas$persona1 %in% c("Peras", "Plátanos"))
```

### La familia de funciones `apply`

Esta familia de funciones es usada para aplicar una función a cada elemento de una estructura de datos.
En particular, es usada para aplicar funciones en matrices, data frames, arreglos y listas.
Para entender más fácilmente el uso de la familia apply, recordemos la vectorización de operaciones.
Hay operaciones que, si las aplicamos a un vector, son aplicadas a todos sus elementos.
La familia apply esta formada por las siguientes funciones:

-   **apply()**

-   **lapply()**

-   **mapply()**

-   **sapply()**

-   eapply()

-   rapply()

-   tapply()

-   vapply()

Es una familia numerosa y esta variedad de funciones se debe a que varias de ellas tienen aplicaciones sumamente específicas.
Las más usadas son las que están en negrita, repasaremos la función apply pero no nos detendremos mucho porque muchas de estas no están al alcance del presente curso.

### apply

`apply` aplica una función a todos los elementos de una **matriz**.

La estructura de esta función es la siguiente.

```{r, eval=FALSE}
apply(X, MARGIN, FUN)
```

`apply` tiene tres argumentos:

-   `X`: Una matriz o un objeto que pueda coercionarse a una matriz, generalmente, un data frame.

-   `MARGIN`: La dimensión (margen) que agrupará los elementos de la matriz `X`, para aplicarles una función.
    Son identificadas con números, **1** son renglones y **2** son colummnas.

-   `FUN`: La función que aplicaremos a la matriz `X` en su dimención `MARGIN`.

Si queremos sumar todas las columnas de una matriz, podemos aplicar esta función, para comparar usaremos también la función `ColSums()` que realiza esta misma operación:

```{r}
matriz<- matrix(1:20, ncol = 5, nrow = 4)
matriz
apply(X = matriz, MARGIN = 2, FUN = sum)
colSums(matriz)
```

También podemos aplicar múltiples funciones a una matriz:

```{r}
multiples.func <- function(x) {
      c(sum = sum(x), prom = mean(x), max = max(x))}
apply(X = matriz, MARGIN = 2, FUN = multiples.func)
```

### Estructuras de control

Estas estructuras nos permiten controlar la manera en que se ejecuta nuestro código.Se establecen como condicionales en nuestros código.
Por ejemplo, qué condiciones deben cumplirse para realizar una operación o qué debe ocurrir para ejecutar una función.

Las estructuras de control más usadas son:

| Estructura de control | Descripción      |
|-----------------------|------------------|
| if, else              | Si, de otro modo |
| while                 | mientras         |
| for                   | Para             |
| break                 | interrumpe       |
| next                  | siguiente        |

También las tocaremos pero no profundizaremos mucho en ellas, pero conoceremos como se utilizan.

#### If, else

If y else se utilizan para crear condiciones, por ejemplo, si cumple esta condición entonces haz esto, de otra manera, haz esto.

Ejemplo:

```{r}
if(10>2) {"Verdadero"
} else {
  "Falso"
}

```

```{r}
if(10<2) {"Verdadero"
} else {
  "Falso"
}
```

También hay una función que reune estas dos condiciones, es`ifelse()` y se usa de igual manera:

```{r}
ifelse((10>2), "Verdadero", "Falso")

```

Podemos aplicarlo en los *data.frames* usando como ejemplo el dataset anterior:

```{r}
ifelse(evaluaciones$notas>7,  "Aprobado", "Reprobado")

```

#### for

La estructura `for` nos permite ejecutar un bucle (*loop*), realizando una operación para cada elemento de un conjunto de datos.

Ejemplo:

```{r}
un_vector<- 1:10
for(i in un_vector) {
 print(i*2)
}
```

### while

Este es un tipo de bucle que ocurre **mientras** una condición es verdadera (`TRUE`).
La operación se realiza hasta que se se llega a cumplir un criterio previamente establecido.
Ejemplo:

```{r}
umbral <- 3
valor <- 0

while(valor < umbral) {
  print("Aún no llegas al umbral")
  valor <- valor + 1
}
```

Para revisar las demás estructuras, podemos revisar la referencia citada[^2]

[^2]: <https://bookdown.org/jboscomendoza/r-principiantes4/estructuras-de-control.html>

### Tratando con datos NA
#### 1. Probando qué tenemos NA en nuestros datos:
```{r}
data <- data.frame(x1 = c(NA, 5, 6, 8, 9),   
                        x2 = c(2, 4, NA, NA, 1), 
                        x3 = c(3,6,7,0,3), 
                        x4 = c("Hola", "algo",
                               NA, "Chao", NA)) 
is.na(data) 
is.na(data$x2)
which(is.na(data))
sum(is.na(data))
```

#### 2. Omitir NAs
```{r}
mean(data$x1, na.rm=TRUE) 
data[complete.cases(data),]
na.omit(data)
data[!is.na(data$x2),]
```


#### 3. Reemplazar NA's
```{r, eval=FALSE}
#reemplazar con 0
data[is.na(data)] <- 0
#reemplazar con el promedio o mediana
data$x1[is.na(data$x1)] <- mean(data$x1, na.rm = TRUE)
data$x2[is.na(data$x2)] <- median(data$x2, na.rm = TRUE)
```

Para ver soluciones más complejas podemos buscar los paquetes *Hmisc* (impute), *mice* (mice) y *rpart* (repart).
